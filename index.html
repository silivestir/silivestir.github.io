
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="keywords" content="kiswahiliScript, programming language, Swahili programming, donut, 3D graphics, visualization">
    <meta name="author" content="Silivestir Assey, Isack Wagunda">
    <meta name="date" content="April 2023">
    <title>kiswahiliScript Documentation</title>
    <style>
        #documentationSwahili { display: none; }
        #toggleButton { margin: 10px; }
    </style>
</head>
<body>
    <button id="toggleButton">Switch to Swahili</button>

    <!-- English Documentation -->
    <div id="documentation">
        <h1>kiswahiliScript Documentation</h1>
        <p><strong>Language:</strong> kiswahiliScript</p>
        <p><strong>Version:</strong> Crafted in April 2023</p>
        <p><strong>Authors:</strong> Silivestir Assey, Isack Wagunda</p>
        <p><strong>Contact:</strong></p>
        <ul>
            <li>Silivestir Assey: silivestirassey@gmx.com</li>
            <li>Isack Wagunda: mwlwaphysicsict@gmail.com</li>
        </ul>
        <p><strong>Contributions:</strong> Open for contributions</p>
        
        <h2>Language Constructs</h2>
        <h3>Function</h3>
        <p>Functions in kiswahiliScript are defined using the <code>kazi</code> keyword. Functions encapsulate a block of code that performs a specific task and can be called from other parts of the code.</p>
        <pre><code>kazi FunctionName() {
    // Function body
}</code></pre>
        <p>Example:</p>
        <pre><code>kazi Salamu() {
    elementi("id,output").kontentiNdani("Habari!");
}</code></pre>

        <h3>Array</h3>
        <p>Arrays in kiswahiliScript are declared using the <code>Data</code> type and are used to store multiple values in a single variable.</p>
        <pre><code>Data arrayName []</code></pre>
        <p>Example:</p>
        <pre><code>Data numbers []
numbers = [1, 2, 3, 4, 5]</code></pre>

        <h3>Object</h3>
        <p>Objects are used to group related data and functions together. In kiswahiliScript, objects can be created and manipulated using specific syntax.</p>
        <pre><code>Data myObject = {
    key1: value1,
    key2: value2
}</code></pre>
        <p>Example:</p>
        <pre><code>Data person = {
    jina: "Ali",
    umri: 30
}</code></pre>

        <h3>Variable</h3>
        <p>Variables in kiswahiliScript are used to store data. They are declared with a type or inferred from the assigned value.</p>
        <pre><code>namba variableName = value</code></pre>
        <p>Example:</p>
        <pre><code>namba age = 25</code></pre>

        <h3>Math Operations</h3>
        <p>kiswahiliScript supports standard arithmetic operations such as addition, subtraction, multiplication, and division.</p>
        <pre><code>namba result = 5 + 3 // Addition
result = 10 - 2 // Subtraction
result = 4 * 2 // Multiplication
result = 8 / 2 // Division</code></pre>

        <h3>Cosine and Sine (cos, sin)</h3>
        <p>The <code>cos</code> and <code>sin</code> functions are used to compute the cosine and sine of an angle in radians, respectively.</p>
        <pre><code>namba angle = 1.57 // Radians
namba cosineValue = cos(angle)
namba sineValue = sin(angle)</code></pre>

        <h3>DOM Manipulation</h3>
        <p>kiswahiliScript can manipulate the Document Object Model (DOM) to interact with and update the content of web pages.</p>
        <pre><code>elementi("id,elementID").kontentiNdani(value)</code></pre>
        <p>Example:</p>
        <pre><code>elementi("id,outputContainer").kontentiNdani("Hello World!")</code></pre>

        <h2>Creating a Donut Visualization</h2>
        <p>kiswahiliScript can be used to create a fascinating donut-like visual effect, similar to the famous donut example by Andy Sloane (2006). This visual effect represents a 3D rotating donut rendered in a 2D text-based display. Here's a brief overview of how it works:</p>
        
        <h3>Concept</h3>
        <p>The donut is visualized using mathematical computations to simulate the appearance of a rotating 3D shape. It involves calculations of angles and coordinates to render the donut on a 2D canvas. This is achieved by calculating the positions and shading of the donut’s surface based on trigonometric functions.</p>

        <h3>Core Components</h3>
        <ul>
            <li><strong>Angles and Rotation:</strong> The donut’s rotation is simulated by incrementing angles (theta and phi) in a loop. This creates the illusion of movement.</li>
            <li><strong>Trigonometric Functions:</strong> Functions like <code>cos</code> and <code>sin</code> are used to compute the position of the donut’s surface points.</li>
            <li><strong>Buffer and Drawing:</strong> A buffer is used to store and update the visual representation of the donut. Characters are used to render the donut's appearance based on depth and light intensity.</li>
            <li><strong>Rendering:</strong> The final visual is created by combining characters based on the computed positions and colors, and then displayed on the screen.</li>
        </ul>

        <h3>Example Overview</h3>
        <p>In the provided kiswahiliScript example, the donut is created using the following steps:</p>
        <ol>
            <li>Initialize variables and buffers for storing the donut's state and appearance.</li>
            <li>Define a function to calculate and update the donut’s frame based on angle increments.</li>
            <li>Use nested loops to compute the positions of points on the donut’s surface using trigonometric functions.</li>
            <li>Update the display based on the computed positions, creating the visual effect of a rotating donut.</li>
        </ol>
    </div>

    <!-- Swahili Documentation -->
    <div id="documentationSwahili">
        <h1>Hati ya kiswahiliScript</h1>
        <p><strong>Lugha:</strong> kiswahiliScript</p>
        <p><strong>Toleo:</strong> Ilitengenezwa mnamo Aprili 2023</p>
        <p><strong>Waandishi:</strong> Silivestir Assey, Isack Wagunda</p>
        <p><strong>Mawasiliano:</strong></p>
        <ul>
            <li>Silivestir Assey: silivestirassey@gmx.com</li>
            <li>Isack Wagunda: mwlwaphysicsict@gmail.com</li>
        </ul>
        <p><strong>Michango:</strong> Fungua kwa michango</p>
        
        <h2>Miundo ya Lugha</h2>
        <h3>Kazi</h3>
        <p>Kazi katika kiswahiliScript hutangazwa kwa kutumia neno <code>kazi</code>. Kazi inajumuisha block ya kanuni inayotekeleza kazi maalum na inaweza kupigiwa simu kutoka sehemu nyingine za kanuni.</p>
        <pre><code>kazi JinaLaKazi() {
    // Mwili wa kazi
}</code></pre>
        <p>Mfano:</p>
        <pre><code>kazi Salamu() {
    elementi("id,output").kontentiNdani("Habari!");
}</code></pre>

        <h3>Array</h3>
        <p>Arrays katika kiswahiliScript hutangazwa kwa kutumia aina ya <code>Data</code> na hutumika kuhifadhi thamani nyingi kwenye variable moja.</p>
        <pre><code>Data jinaArray []</code></pre>
        <p>Mfano:</p>
        <pre><code>Data nambari []
nambari.weka(1, 2, 3, 4, 5)</code></pre>

        
                <h3>Object</h3>
        <p>Objects hutumika kuunganisha data na kazi zinazohusiana pamoja. Katika kiswahiliScript, objects zinaweza kuundwa na kusimamiwa kwa kutumia syntax maalum.</p>
        <pre><code>Data objectYangu = {
    ufunguo1: thamani1,
    ufunguo2: thamani2
}</code></pre>
        <p>Mfano:</p>
        <pre><code>Data mtu = {
    jina: "Ali",
    umri: 30
}</code></pre>

        <h3>Variable</h3>
        <p>Variables katika kiswahiliScript hutumika kuhifadhi data. Zinatangazwa kwa aina au zinasalimishwa kutoka kwa thamani iliyopewa.</p>
        <pre><code>namba jinaVariable = thamani</code></pre>
        <p>Mfano:</p>
        <pre><code>namba umri = 25</code></pre>

        <h3>Math Operations</h3>
        <p>kiswahiliScript inaunga mkono operesheni za hesabu kama vile kuongeza, kupunguza, kuzidisha, na kugawanya.</p>
        <pre><code>namba matokeo = 5 + 3 // Kuongeza
matokeo = 10 - 2 // Kupunguza
matokeo = 4 * 2 // Kuzidisha
matokeo = 8 / 2 // Kugawanya</code></pre>

        <h3>Cosine na Sine (cos, sin)</h3>
        <p>Mbinu <code>cos</code> na <code>sin</code> hutumika kuhesabu cosine na sine ya angle kwa radians, mtawalia.</p>
        <pre><code>namba angle = 1.57 // Radians
namba cosineThamani = cos(angle)
namba sineThamani = sin(angle)</code></pre>

        <h3>DOM Manipulation</h3>
        <p>kiswahiliScript inaweza kudhibiti Document Object Model (DOM) ili kuingiliana na kubadilisha maudhui ya kurasa za wavuti.</p>
        <pre><code>elementi("id,elementID").kontentiNdani(thamani)</code></pre>
        <p>Mfano:</p>
        <pre><code>elementi("id,outputContainer").kontentiNdani("Hello World!")</code></pre>

        <h2>Kuunda Onyesho la Donati</h2>
        <p>kiswahiliScript inaweza kutumika kuunda athari ya kuvutia ya donati, inayofanana na mfano maarufu wa donati kutoka kwa Andy Sloane (2006). Athari hii ya kuona inawakilisha umbo la donati la 3D linalozunguka, lililowasilishwa kwenye skrini ya 2D kwa kutumia maandiko. Hapa kuna muhtasari wa jinsi inavyofanya kazi:</p>
        
        <h3>Concept</h3>
        <p>Donati inavyoonekana kwa kutumia hesabu za kijiometri ili kuonyesha muonekano wa umbo la 3D lililojaa. Inahusisha mahesabu ya pembe na kuratibu ili kuonyesha donati kwenye jukwaa la 2D. Hii inafikiwa kwa kuhesabu nafasi na kivuli cha uso wa donati kulingana na shughuli za trigonometri.</p>

        <h3>Sehemu Muhimu</h3>
        <ul>
            <li><strong>Pembe na Mzunguko:</strong> Mzunguko wa donati unavyoonyeshwa kwa kuongeza pembe (theta na phi) kwenye mzunguko. Hii huunda mwonekano wa mwendo.</li>
            <li><strong>Shughuli za Trigonometri:</strong> Mbinu kama <code>cos</code> na <code>sin</code> hutumika kuhesabu nafasi za sehemu za uso wa donati.</li>
            <li><strong>Buffer na Uchoraji:</strong> Buffer hutumika kuhifadhi na kuboresha mwonekano wa donati. Mipangilio hutumika kuchora muonekano wa donati kulingana na kina na mwangaza.</li>
            <li><strong>Uwasilishaji:</strong> Mwonekano wa mwisho huundwa kwa kuchanganya wahusika kulingana na nafasi na rangi zilizohesabiwa, na kisha kuonyeshwa kwenye skrini.</li>
        </ul>

        <h3>Muonekano wa Mfano</h3>
        <p>Katika mfano wa kiswahiliScript uliopewa, donati inaundwa kwa hatua zifuatazo:</p>
        <ol>
            <li>Anzisha variables na buffers kwa ajili ya kuhifadhi hali na muonekano wa donati.</li>
            <li>Tambua kazi ya kuhesabu na kuboresha fremu ya donati kulingana na ongezeko la pembe.</li>
            <li>Tumia miduara ya kurudi kuhesabu nafasi za alama kwenye uso wa donati kwa kutumia shughuli za trigonometri.</li>
            <li>Boreshia onyesho kulingana na nafasi zilizohesabiwa, na kuunda athari ya donati inayozunguka.</li>
        </ol>
    </div>

    <script>
        document.getElementById('toggleButton').addEventListener('click', function() {
            var englishDoc = document.getElementById('documentation');
            var swahiliDoc = document.getElementById('documentationSwahili');
            if (englishDoc.style.display === 'none') {
                englishDoc.style.display = 'block';
                swahiliDoc.style.display = 'none';
                this.textContent = 'Switch to Swahili';
            } else {
                englishDoc.style.display = 'none';
                swahiliDoc.style.display = 'block';
                this.textContent = 'Switch to English';
            }
        });
    </script>
</body>
</html>





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kiswahiliScript</title>

    <!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

    <!-- FontAwesome for icons from CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <!-- CodeMirror CSS from CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">

    <!-- CodeMirror JS from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>

    <!-- jQuery from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

    <!-- CodeMirror Show-Hint CSS from CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
</head>
    <style>
    pre{
      color: white;
    }
    body{
      color:green;
      background-color:#282d36;
    }
        .CodeMirror {
            border: 1px solid #ddd;
            height: auto;
        }
        .hidden {
            display: none;
        }
        .file-list {
            display: flex;
            overflow-x: auto;
            padding: 10px 0;
        }
        .file-list-item {
            cursor: pointer;
            padding: 10px;
            margin-right: 10px;
            border-radius: 4px;
            text-align: center;
            transition: background-color 0.3s, color 0.3s;
        }
        .file-list-item:hover {
            background-color: #f1f1f1;
        }
        .file-list-item.active {
            background-color: #007bff;
            color: white;
            border-bottom: 3px solid #0056b3;
        }
        .navbar {
            margin-bottom: 20px;
        }
        .file-list-item i {
            font-size: 24px;
        }
        #outputContainer {
           
            
            
           
          
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            outline: 0;
        }
        .modal-dialog {
            position: relative;
            width: auto;
            margin: 10px;
        }
        .modal-content {
            position: relative;
            background-color: #fff;
            border: 1px solid #999;
            border-radius: .3rem;
            outline: 0;
            box-shadow: 0 3px 9px rgba(0,0,0,.5);
        }
        .modal-header {
            padding: .75rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }
        .modal-body {
            position: relative;
            padding: 1.25rem;
        }
        .modal-footer {
            padding: .75rem 1.25rem;
            border-top: 1px solid #e9ecef;
            text-align: right;
        }
        .modal-open .modal {
            display: block;
        }
    </style>
</head>
<body>
  <div>kiswahiliScript compailer initialized with donut codes</div>
    <div class="container mt-4">
        <div class="navbar navbar-expand-lg navbar-light bg-light">
            <button class="btn btn-primary mr-2" onclick="openModal()">
                <i class="fas fa-plus"></i> Create File
            </button>
            <button class="btn btn-warning mr-2" onclick="toggleTerminal()">
    <i class="fas fa-terminal"></i> Terminal
</button>
            
            
            <button class="btn btn-secondary mr-2" onclick="toggleEditor()">
                <i class="fas fa-toggle-on"></i> Output
            </button>
            
            
            
            <button class="btn btn-success" onclick="saveFile()">
                <i class="fas fa-save"></i> Save File
            </button>
        </div>

        <!-- File List -->
        <div id="fileList" class="file-list mt-2"></div>

        <!-- Editor Container -->
        <div id="editorContainer" class="mt-2">
            <textarea id="code"></textarea>
        </div>


<!-- Terminal Container -->
<div id="terminalContainer" class="mt-2 hidden">
    <div id="terminalOutput" class="border p-3" style="background: #000; color: #fff; font-family: monospace; height: 300px; overflow-y: auto;"></div>
    <textarea id="terminalInput" class="form-control mt-2" rows="3" placeholder="Type your command here..."></textarea>
</div>



        <!-- Output Container -->
        
        <div id="outputContainer" class="mt-2 hidden">
            <div id="s"></div>
        </div>

        <!-- File Modal -->
        <div class="modal" id="fileModal">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Create New File</h5>
                        <button type="button" class="close" onclick="closeModal()">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <form id="fileForm">
                            <div class="form-group">
                                <label for="fileName">File Name (must end with .kiss)</label>
                                <input type="text" class="form-control" id="fileName" required>
                            </div>
                            <button type="submit" class="btn btn-primary">Create File</button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <script>
        // Initialize CodeMirror editor
        var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
            mode: "javascript",
            theme: "dracula",
            lineNumbers: true,
            matchBrackets: true,
            autoCloseBrackets: true,
            extraKeys: {
                "Ctrl-Space": "autocomplete"
            }
        });
        
        
        editor.setValue(`kazi TengenezaDonatiLinaloZunguka() {
      
     
     sentensi timer=""
      timer = null;
     namba theta_sp = 0
     namba phi_sp = 0
     Data b []
     Data zBuffer []
     
     
     
     
     kazi ChoraFremuZaDonati() {
     theta_sp =theta_sp+0.07;
     phi_sp =phi_sp+ 0.03;
     
     cosTheta_sp = cos(theta_sp)
     sinTheta_sp = sin(theta_sp)
     cosPhi_sp = cos(phi_sp)
     sinPhi_sp = sin(phi_sp)
     
 
   ikiwa(namba k = 0; k < 1760; k++) {
     b[k] = k % 80 == 79 ? "\\n" : "..";
    
     }
     
     
     
      ikiwa (namba k = 0; k < 1760; k++) {
     
     zBuffer[k] = 0;
     }
     
     ikiwa (namba theta = 0; theta < 6.28; theta += 0.07) {
      cosTheta = cos(theta)
      sinTheta = sin(theta)
 
     ikiwa (namba phi = 0; phi < 6.28; phi += 0.02) {
      sinPhi = sin(phi)
      cosPhi = cos(phi)
      circleX = cosTheta + 2;
     z =
     sinPhi * circleX * sinTheta_sp + sinTheta * cosTheta_sp + 5;
      D = 1 / z;
      t =
     sinPhi * circleX * cosTheta_sp - sinTheta * sinTheta_sp;
      x=
    0.01 |(40 +
     30 *
     D *
     (cosPhi * circleX * cosPhi_sp - t * sinPhi_sp));
     
     
      y=
     0 |
     (12 +
     15 *
     D *
     (cosPhi * circleX * sinPhi_sp + t * cosPhi_sp));
     
     
     
     o = x + 80 * y;
     
     
     
     
     
      N =
     0 |
     (8 *
     ((sinTheta * sinTheta_sp -
     sinPhi * cosTheta * cosTheta_sp) *
     cosPhi_sp -
     sinPhi * cosTheta * sinTheta_sp -
     sinTheta * cosTheta_sp -
     cosPhi * cosTheta * sinPhi_sp));
     
     kama (
     y < 22 &&
     y >= 0 &&
     x >= 0 &&
     x < 79 &&
     D > zBuffer[o]
     ) {
     zBuffer[o] = D;
          b[o]="00000000011111111111111"[N>0?N:0];
     }
     
     }
     
     }
     
     
     
     
      aa=b.join("");
      
     elementi("id,outputContainer").kontentiNdani(aa)
     }
     kazi FanyaDonatiLizunguke() {
     kama(timer === null) {
     namba a=50
     timer = setInterval(ChoraFremuZaDonati, a)
     } (){
     
timer= clearInterval(timer)
}
    }
     
   FanyaDonatiLizunguke()
     
     
     
    }
     
   TengenezaDonatiLinaloZunguka()
     
     
     `)

        // File management
        var files = {};
        var currentFileName = null;

        function createFile(name) {
            if (!name.endsWith('.kiss')) {
                alert('File must end with .kiss');
                return;
            }
            if (files[name]) {
                alert('File already exists');
                return;
            }
            files[name] = '';
            currentFileName = name; // Set current file to newly created one
            updateFileList();
            closeModal();
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            Object.keys(files).forEach(fileName => {
                const div = document.createElement('div');
                div.className = 'file-list-item' + (fileName === currentFileName ? ' active' : '');
                div.innerHTML = `<i class="fas fa-file-code"></i><br>${fileName}`;
                div.onclick = () => loadFile(fileName);
                fileList.appendChild(div);
            });
        }

        function loadFile(name) {
            currentFileName = name;
            editor.setValue(files[name]);
            document.getElementById('editorContainer').classList.remove('hidden');
            document.getElementById('outputContainer').classList.add('hidden');
            updateFileList(); // Update the file list to reflect the selected file
        }

        function saveFile() {
            if (currentFileName) {
                files[currentFileName] = editor.getValue();
                alert('File saved!');
            } else {
                alert('No file selected to save.');
            }
        }

        function toggleEditor() {
            var editorContainer = document.getElementById('editorContainer');
            var outputContainer = document.getElementById('outputContainer');

            if (editorContainer.classList.contains('hidden')) {
                editorContainer.classList.remove('hidden');
                outputContainer.classList.add('hidden');
            } else {
                editorContainer.classList.add('hidden');
               
                editorContainer.classList.add('hidden');
                outputContainer.classList.remove('hidden');
                Compile();
            }
        }








class Environment {
  constructor(enclosing) {
    this.errorHandler = new ErrorHandler();
    this.values = {};
    this.enclosing = null;
    if (enclosing) {
      this.enclosing = enclosing;
    };
  };

  define(identifier, value) {
    this.values[identifier] = value;
  };

  assign(identifier, value) {
    if (!Object.keys(this.values).includes(identifier))
    {
      if (this.enclosing) 
      {
        return this.enclosing.assign(identifier, value);
      } 
      else 
      {
        this.errorHandler.throw(
          `UNDEFINED VARIABLE ${identifier}`
        );
      }
    } 
    else 
    {
      this.values[identifier] = value;
    };
  };

  get(identifier) {
    if (Object.keys(this.values).includes(identifier)) 
    {
      return this.values[identifier];
    }
    else 
    {
      if (this.enclosing) 
      {
        return this.enclosing.get(identifier);
      };
      this.errorHandler.throw(
        `UNDEFINED VARIABLE ${identifier}`
      );
    };
  };
};








class ErrorHandler {
  constructor() {
    this.log = globalLog;
  };

  throw(msg, line, col) {
    let err;
    if (line && col) {
      err = `\n\n${msg} -- ln: ${line}, col: ${col}\n`
    } else {
      err = `\n\n${msg}\n`
    };
    try {
      throw new Error(err);
    } catch (e) {
      console.error(e);
      this.log.error(e, line);
      // process.exit(1);
    };
  };
};



class Assignment {
  constructor(token, expression, evaluator, environment) {
    this.identifier = token.value;
    this.expression = expression;

    this.evaluator = evaluator;
    this.environment = environment;
    this.evaluator.load(expression);
    this.value = this.evaluator.evaluate().value;
    this.operate();
  };
  operate() {
    this.environment.assign(this.identifier, this.value);
  };
};

class Binary {
  constructor(leftNode, operator, rightNode, evaluator) {
    this.evaluator = evaluator;

    this.evaluator.load(leftNode);
    this.leftNode = this.evaluator.evaluate();

    this.evaluator.load(rightNode);
    this.rightNode = this.evaluator.evaluate();
    
    this.operator = operator.type;
    this.value = this.operate();
  };

  operate() {
    if (this.operator == 'PLUS') {
      return this.leftNode.value + this.rightNode.value;
    };
    if (this.operator == 'MINUS') {
      return this.leftNode.value - this.rightNode.value;
    };
    if (this.operator == 'MULTIPLY') {
      return this.leftNode.value * this.rightNode.value;
    };
    if (this.operator == 'DIVIDE') {
      return this.leftNode.value / this.rightNode.value;
    };
    if (this.operator == 'MODULO') {
      return this.leftNode.value % this.rightNode.value;
    };
    if (this.operator == 'EQUALTO') {
      return this.leftNode.value == this.rightNode.value;
    };
    if (this.operator == 'NOTEQUALTO') {
      return this.leftNode.value != this.rightNode.value;
    };
    if (this.operator == 'GREATERTHAN') {
      return this.leftNode.value > this.rightNode.value;
    };
    if (this.operator == 'LESSTHAN') {
      return this.leftNode.value < this.rightNode.value;
    };
    if (this.operator == 'GREATERTHANEQUAL') {
      return this.leftNode.value >= this.rightNode.value;
    };
    if (this.operator == 'LESSTHANEQUAL') {
      return this.leftNode.value <= this.rightNode.value;
    };
  }
};

class Unary {
  constructor(operator , expression, evaluator) {
    this.evaluator = evaluator;
    this.evaluator.load(expression);

    this.operator = operator;
    this.expression = expression;
    this.value = this.operate();
  }
  operate() {
    if (this.operator.type == "MINUS") {  
      return ( - ( this.evaluator.evaluate().value ) );
    };
    if (this.operator.type == "PLUS") {
      return (this.evaluator.evaluate().value);
    }
    if (this.operator.type == "NOT") {
      return !(this.evaluator.evaluate().value);
    }
  };
}

class Call {
  constructor(callee, args, evaluator, environment) {
    this.errorHandler = new ErrorHandler();
    this.callee = callee;
    this.evaluator = evaluator;
    this.args = this.evaluateArgs(args);
    this.environment = environment;
    this.value = this.operate();
  };

  evaluateArgs(args) {
    let parsedArgs = [];
    for (let arg of args) {
      this.evaluator.load(arg);
      let argValue = this.evaluator.evaluate().value;
      parsedArgs.push(argValue);
    }
    return parsedArgs;
  };

  operate() {
    const zapFunction = this.environment.get(this.callee.value);
    if (!(zapFunction instanceof ZapFunction)) {
      this.errorHandler.throw(
        `INVALID CALLEE TYPE`,
        this.callee.line,
        this.callee.col,
      );
    };
    return zapFunction.call(this.args);
  };
};

class Literal {
  constructor(token) {
    if (token.type == "NUMBER") {
      this.value = parseFloat(token.value);
    };
    if (token.type == "STRING") {
      this.value = token.value;
    };
  };
};

class Group {
  constructor(expression, evaluator) {
    this.evaluator = evaluator;
    this.evaluator.load(expression);
    this.value = this.evaluator.evaluate().value;
  };
};

class Variable {
  constructor(token, environment) {
    this.identifier = token.value;
    this.environment = environment;
    this.value = this.fetchValue();
  }
  fetchValue() {
    return this.environment.get(this.identifier);
  };
}

/*
                 ::::{[{[ --> THE EVALUATING LOGIC <-- ]}]}::::

        The logic behind the evaluator is to create a tree of operations.
      It starts by iterating through the Whole raw expression (token list),
                            from right to left,
              trying to find the operators of lowest precedence 
                    (the ones that will be executed last).
              As soon as it finds an operator of type "+" or "-",
                 it becomes the first expression in the tree.
       The expressions can be of 4 types: Binary, Unary, Group or Literal.

             The Evaluator will iterate through the raw Expression,
                  Always trying break down bigger expressions
             into smaller ones until it works with only Primaries.

                             THE EXPRESSION TYPES

          Binary Expressions :
            --> Have a left and right sub-expression, along with an operator.
            --> The expression's value is calculated by
                joining the values of the left and right 
                sub-expressions through the operator.
            --> EXAMPLES:
      
          1.     "PLUS"                    2.        "MULTPLY"                                            
                   /\                                    /\                            
                  /  \                                  /  \                           
                 5    6                               5+6  7-3                    
                                                                                  
           Calculated Value: 11                  Calculated Value: 44                                                                 
                         
            --> {{ RECURSION ALERT }}
                Notice how in Example 2,
                the sub-expressions are also of type "Binary Expression"   



          Unary Expressions :
            --> Have a sub-expression, along with a unary operator ("!" or "-").
            --> The expression's value is calculated by
                joining the value of the sub-expression with the operator.
            --> EXAMPLES:
      
          1.     "PLUS"                    2.        "MINUS"                                            
                    |                                   |                           
                    5                                   9                     
                                                                
                                                                                  
           Calculated Value: 5                  Calculated Value: -9                                                                 
                          


          Group Expressions :
            --> Are the ones in between parenthesis.
            --> The expression's value is calculated by parsing
                the expression in between parenthesis.
            --> Examples:
          
          1.    "(2 + 3)"                                                             
                    |
                    V                                                         
                   2+3    
                    |
                    V
                  "PLUS"                                           
                    /\                                            
                   /  \
                  2    3
                   
           Calculated Value: 5                   
                
                     
           
          Primary Expressions :
            --> Are the ones that represent a Literal (String, Int, Float, etc.).
            --> The expression's value is the Literal it holds.
            --> Examples:
          
          1.      "245"                                                             
                    
           Calculated Value: 245                              


                            {[{[ --> EXAMPLE <--]}]}
                                                                                                                                                                                  
                    (3 + 5) - 8 * (4 - (8 / 2) - 7) + 4 * (9)                                                                                                                                                    
                                                    |                                                                                                                              
                                                  "PLUS"                                                                                                                                           
                                                    /\                                                                                                                                         
                                                   /  \                                                                                                                                        
                     (3 + 5) - 8 * (4 - (8 / 2) - 7)   4 * (9)                                                                                                                                                                 
                             |                           |                                    
                          "MINUS"                      "MULT"                                                                                                                                  
                            /\                           /\                                                                                                                                                                                       
                           /  \                         4   (9)                                                                                                                                                       
                          /    \                             |                                                                    
                  (3 + 5)      8 * (4 - (8 / 2) - 7)         9                                                                                       
                /                |                                                                                                          
          GROUP(3+5)         "MULTIPLY"                                                                                                      
              |                  /\                                                                                         
            3 + 5               /  \                                                                     
              |                8    (4 - (8 / 2) - 7)                                                         
            "PLUS"                          |                             
              /\                     4 - (8 / 2) - 7                                                     
             /  \                                |                                         
            3    5                            "MINUS"                                 
                                                 /\                             
                                                /  \                              
                                    4 - (8 / 2)      7                         
                                      |                                        
                                   "MINUS"                                          
                                      /\                                                                        
                                     /  \                                                                                                        
                                    4    (8 / 2)                                                                    
                                            |                                                                
                                          8 / 2                                                                  
                                            |                                                                
                                         "DIVIDE"                                                                   
                                            /\                                                                
                                           /  \        
                                          8    2
                                           

*/

class Evaluator {
  constructor(environment) {
    this.environment = environment;

    this.errorHandler = new ErrorHandler();
    this.rawExpression = null;
    this.index = null;
    this.previousToken = null;
    this.currentToken = null;
    this.nextToken = null;
    this.openingParen = 0;
    this.closingParen = 0;
    this.bars = 0;
  };

  load(tokens) {
    this.rawExpression = tokens;
    this.resetToEnd();
  }

  reset() {
    this.index = 0;
    this.previousToken = null;
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = this.rawExpression[this.index+1];
    this.openingParen = 0;
    this.closingParen = 0;

    this.checkParenthese();
    this.checkBar();
  };

  resetToEnd() {
    this.index = this.rawExpression.length - 1;
    this.previousToken = this.rawExpression[this.index - 1];
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = null;
    this.openingParen = 0;
    this.closingParen = 0;

    this.checkParenthese();
    this.checkBar();
  };

  next() {
    this.index++;
    this.previousToken = this.rawExpression[this.index-1];
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = this.rawExpression[this.index+1];
    
    this.checkParenthese();
    this.checkBar();
  };

  prev() {
    this.index--;
    this.previousToken = this.rawExpression[this.index-1];
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = this.rawExpression[this.index+1];
    
    this.checkParenthese();
    this.checkBar();
  };

  checkParenthese() {
    if (this.currentToken) {
      if (this.currentToken.type == "LPAREN") {
        this.openingParen++;
      };
      if (this.currentToken.type == "RPAREN") {
        this.closingParen++;
      };
    };
  };

  checkBar() {
    if (this.currentToken) {
      if (this.currentToken.type == "BAR") {
        this.bars++;
      };
    };
  };

  isInGroup() {
    return (this.openingParen != this.closingParen) || (this.bars % 2 != 0);
  }

  isOperator(token) {
    let operators = [
      "MULTIPLY", 
      "DIVIDE", 
      "PLUS", 
      "MINUS", 
      "MODULO", 
      "GREATERTHAN", 
      "GREATERTHANEQUAL",
      "LESSTHAN",
      "LESSTHANEQUAL", 
      "EQUALTO",
      "NOTEQUALTO",
      "NOT",
    ];
    return (operators.includes(token.type) );
  };

  isEqualityOperator(token) {
    let operators = [
      "EQUALTO",
      "NOTEQUALTO",
    ];
    return (operators.includes(token.type) );
  }

  isComparissonOperator(token) {
    let operators = [ 
      "GREATERTHAN", 
      "GREATERTHANEQUAL",
      "LESSTHAN",
      "LESSTHANEQUAL", 
    ];
    return (operators.includes(token.type) );
  }

  isAdditionOperator(token) {
    let operators = [
      "PLUS",
      "MINUS",
    ];
    return (operators.includes(token.type) );
  }

  isMultiplicationOperator(token) {
    let operators = [
      "MULTIPLY",
      "DIVIDE",
      "MODULO",
    ];
    return (operators.includes(token.type) );
  }

  isUnaryOperator(token) {
    let operators = [
      "MINUS",
      "NOT",
      "PLUS",
    ];
    return (operators.includes(token.type) );
  }

  isLiteral(token) {
    let types = [
      "STRING",
      "NUMBER",
    ];
    return (types.includes(token.type) );
  }

  isReserved(token) {
    let types = [ 
      "FOR", 
      "WHILE",
      "RETURN",
      "SHOW", 
    ];
    return types.includes(token.type);
  };

  isForbidden(token) {
    let types = [ 
      "RBRACE",
      "LBRACE",
      "SEMICOLON", 
      "DOT",
      "DECLARATOR",
    ];
    return types.includes(token.type);
  }

  handleAssignment() {
    // console.log('isAssignment')
    let assigned = this.rawExpression.slice(0, this.index);
    let expression = this.rawExpression.slice(this.index+1);

    if (assigned.length != 1 || !expression.length) {
      this.errorHandler.throw(
        'UNABLE TO PARSE ASSIGNMENT',
        this.currentToken.line,
        this.currentToken.col
      );
    };

    let identifier = assigned[0];

    if (identifier.type != 'IDENTIFIER') {
      this.errorHandler.throw(
        'INVALID ASSIGNEE',
        this.currentToken.line,
        this.currentToken.col
      );
    };

    let node = new Assignment(
      identifier,
      expression,
      this,
      this.environment
    );
    return node;
  };

  handleBinary() {
    // console.log('isBinary')
    let leftNode = this.rawExpression.slice(0, this.index);
    let rightNode = this.rawExpression.slice(this.index+1);

    if (!leftNode.length || !rightNode.length) {
      this.errorHandler.throw(
        'UNABLE TO PARSE BINARY EXPRESSION',
        this.currentToken.line,
        this.currentToken.col
      );
    };

    let node = new Binary(
      leftNode,
      this.currentToken,
      rightNode,
      this
    )
    return node;
  }

  handleUnary() {
    // console.log('isUnary')
    let expr = this.rawExpression.slice(this.index+1);

    if (!expr.length) {
      this.errorHandler.throw(
        'UNABLE TO PARSE UNARY EXPRESSION',
        this.currentToken.line,
        this.currentToken.col
      );
    }

    let node = new Unary(
      this.currentToken,
      expr,
      this,
    );
    return node;
  };

  handleCall() {
    let callee = this.previousToken;
    let args = [];
    let currentArgument = [];

    this.next();
    if (!this.currentToken) {
      this.errorHandler.throw(
        `UNABLE TO PARSE CALL EXPRESSION`,
        this.previousToken.line,
        this.previousToken.col
      );
    }

    while (this.currentToken.type != 'BAR') {
      if (this.currentToken.type != 'COMMA') {
        currentArgument.push(this.currentToken);
      } else {
        args.push(currentArgument);
        currentArgument = [];
      };
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '|' after argument list`,
          this.previousToken.line,
          this.previousToken.col
        )
      };
    };

    if (currentArgument.length) {
      args.push(currentArgument);
      currentArgument = [];
    }
    
    let node = new Call(
      callee,
      args,
      this,
      this.environment,
    )
    return node;
  };

  handleOpenParen() {
    // console.log('isGroup')
    let group = []
    while (this.isInGroup()) {
      group.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(`EXPECTED ')' AFTER EXPRESSION -- EOF`);
      };
    };
    let node = new Group(
      group,
      this
      );
    return node;
  };

  handlePrimary() {
    // console.log('isPrimary')
    let node = new Literal(this.currentToken);
    return node;
  };

  handleVariable() {
    // console.log('isVariable')
    let node = new Variable(
      this.currentToken, 
      this.environment
    );
    return node;
  };

  handleReserved() {
    this.errorHandler.throw(
      'UNEXPECTED KEYWORD',
      this.currentToken.line,
      this.currentToken.col,
    );
  };

  handleForbidden() {
    this.errorHandler.throw(
      'FORBIDDEN SYMBOL IN EXPRESSION',
      this.currentToken.line,
      this.currentToken.col,
    );
  };

  evaluate() {
    // console.log('expression to parse');
    // console.log(this.rawExpression);

    /*
      Parsing the expressions with lowest precedence (EQUALITY)
      We iterate through the rawExpression from right to left due to the association rule of these operators.

      The order of precedence is as follows
      --> EQUALITY
      --> COMPARISSON
      --> ADDITION - SUBTRACTION
      --> MULTIPLICATION - DIVISION
      --> UNARY
      --> GROUP
      --> PRIMARY
    */


    while (this.currentToken) {
      if (this.isForbidden(this.currentToken)) {
        this.handleForbidden();
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.currentToken) {
      if (this.isReserved(this.currentToken)) {
        this.handleReserved();
      };
      this.prev();
    };
    this.reset();

    while (this.currentToken && this.nextToken) {
      if (this.isLiteral(this.currentToken) && this.isLiteral(this.nextToken)) { 
        this.errorHandler.throw(
          'UNEXPECTED LITERAL',
          this.nextToken.line,
          this.nextToken.col
        );
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == 'EQUALS') {
        if (!this.isInGroup()) {
          return this.handleAssignment();
        };
      };
      this.next();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isEqualityOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleBinary();
        };
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isComparissonOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleBinary();
        };
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isAdditionOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          if (this.previousToken) {
            if (!this.isOperator(this.previousToken)) {
              return this.handleBinary();
            };
          };
        };
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isMultiplicationOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleBinary();
        };
      };
      this.prev();
    };
    this.reset();

    while (this.currentToken) {
      if (this.isUnaryOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleUnary();
        };
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == 'BAR') {
        return this.handleCall();
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == "LPAREN") {
        this.next();
        return this.handleOpenParen();
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == "NUMBER" || this.currentToken.type == "STRING") {
        return this.handlePrimary();
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == "IDENTIFIER") {
        return this.handleVariable();
      };
      this.next();
    };
    this.reset();

    return {
      value : undefined,
    };

  };
};




// const { Environment } = require('../environment/Environment');
// const { Lexer } = require('../lexer/lexer');

// console.time('parsing')
// const env = new Environment();
// const lexer = new Lexer("1");
// const parser = new Parser(env);
// parser.load(lexer.tokens);
// result = parser.parse();
// console.log(result);

// console.timeEnd('parsing')



class Interpreter {
  constructor(input) {
    globalLog.clear();
    
    this.errorHandler = new ErrorHandler();
    this.environment = new Environment(null);
    this.lexer = new Lexer(input);
    this.parser = new Parser(this.environment);
    this.parser.load(this.lexer.tokens);
    this.statements = this.parser.parse();
  };
};




class CharSeperator {
  constructor(input) {
    this.errorHandler = new ErrorHandler();
    this.input = input;
    this.charTypes = [];
    this.getCharTypes();
  };

  getCharTypes() {
    let line = 1;
    let col = 1;
    for (let char of this.input.split('')) {
      for (let [ token , verification ] of Object.entries(tokenList)) {
        if (verification(char)) {
          const charDescription = {};
          charDescription['type'] = token;
          charDescription['line'] = line;
          charDescription['col'] = col;
          charDescription['value'] = char;
          if (charDescription.type == "UNRECOGNIZED") {
            this.errorHandler.throw(`UNRECOGNIZED SYNTAX`, charDescription['line'], charDescription['col']);
          } else {
            this.charTypes.push(charDescription);
          };
          break;
        }
      }
      if (char == '\n') {
        col = 1;
        line++;
      } else {
        col++;
      };
    };
  };
};


/*



                          {[{[ --> THE LEXER <-- ]}]}

                  The goal here is to take a stream of inputs
               & separate it into tokens that have meaning to the
                                   language.

               We start by separating each character of the stream
                                  by its type.
                             The possible types are:

           1. +  2. -  3. *  4. /  5. %  6. =  7. == 8. != 9. >  10.  <

           11.<= 12.<= 13. ! 14. ( 15. ) 16. { 17. } 18. ; 19. ' 20. .

       Besides these types, the char can be a Letter, Number or Whitespace.


              After classifying all the characters, we can move on
          to grouping these symbols into larger lexemes or tokens that
                   our language will be able to understand.



*/


class Lexer {
  constructor (input) {
    this.charSeperator = new CharSeperator(input);
    this.errorHandler = new ErrorHandler();
    this.charTypes = this.charSeperator.charTypes;
    this.index = 0;
    this.char = this.charTypes[this.index];
    this.currentToken = {};
    this.tokens = [];
    this.lex();
  }

  resetCurrentToken() {
    this.currentToken = {};
  }

  next() {
    this.index++;
    this.char = this.charTypes[this.index];
  };

  peakNext() {
    try {
      return this.charTypes[this.index + 1];
    } catch {
      return false;
    };
  };

  handleStr() {
    this.currentToken = {
      "type" : "STRING",
      "line" : this.char.line,
      "col" : this.char.col,
      "value" : "",
    };

    if (this.peakNext()) {
      this.next();
    } else {
      this.errorHandler.throw('EOF WHILE PARSING STRING', this.currentToken.line, this.currentToken.col);
    }

    while (this.char.type != "QUOTE") {
      this.currentToken.value = this.currentToken.value.concat(this.char.value);
      this.next();
      if (!this.char) {
        this.errorHandler.throw('EOF WHILE PARSING STRING', this.currentToken.line, this.currentToken.col);
      };
    };
    this.tokens.push(this.currentToken);
    this.resetCurrentToken();
    this.next();
    this.lex();
  };

  handleNum() {
    let hasDecimal = false;

    this.currentToken = {
      "type" : "NUMBER",
      "line" : this.char.line,
      "col" : this.char.col,
      "value" : "",
    };

    // Long statements to handle decimal and int numbers
    while (this.char.type == "NUMBER" || (!hasDecimal && this.char.type == "DOT" && this.peakNext() && this.peakNext().type == "NUMBER")) {
      if (this.char.type == "DOT") {
        hasDecimal = true;
      };
      this.currentToken.value = this.currentToken.value.concat(this.char.value);
      this.next();
      if (!this.char) {
        break;
      };
    };
    this.tokens.push(this.currentToken);
    this.resetCurrentToken();
    this.lex();
  };

  handleId() {
    this.currentToken = {
      "type" : "IDENTIFIER",
      "line" : this.char.line,
      "col" : this.char.col,
      "value" : "",
    };

    while (this.char.type == "NUMBER" || this.char.type == "LETTER") {
      this.currentToken.value = this.currentToken.value.concat(this.char.value);
      this.next();
      if (!this.char) {
        break;
      };
    };

    if (Object.keys(reserved).includes(this.currentToken.value)) {
      this.currentToken.type = reserved[this.currentToken.value];
    };

    this.tokens.push(this.currentToken);
    this.resetCurrentToken();
    this.lex();
  };


  isDoubleCharOperator() {
    if (this.peakNext()) {
      let operatorToTest = this.char.value.concat(this.peakNext().value)
      for (let [ type , verification ] of Object.entries(tokenList)) {
        if (verification(operatorToTest) && (type != "UNRECOGNIZED")) {
          return {
            "type" : type,
            "line" : this.char.line,
            "col" : this.char.col,
            "value" : operatorToTest,
          };
        };
      };
      return false;
    };
  };

  handleOperator() {
    if (this.char.type != "WHITESPACE") {
      let doubleCharOperator = this.isDoubleCharOperator();
      if (doubleCharOperator) {
        this.next();
        this.currentToken = doubleCharOperator;
        this.tokens.push(this.currentToken);
        this.resetCurrentToken();
      } else {
        this.currentToken = this.char;
        this.tokens.push(this.currentToken);
        this.resetCurrentToken();
      };
    };
    this.next();
    this.lex();
  };

  lex() {
    if (this.char) {
      switch(this.char.type) {
        case "QUOTE":
          this.handleStr();
          break;
        case "NUMBER":
          this.handleNum();
          break;
        case "LETTER":
          this.handleId();
          break;
        default:
          this.handleOperator();
      };
    };
  };
};





const tokenList = {
  "PLUS" : (input) => input == '+',
  "MINUS" : (input) => input == '-',
  "DIVIDE" : (input) => input == '/',
  "MULTIPLY" : (input) => input == '*',
  "MODULO" : (input) => input == '%',

  "EQUALS" : (input) => input == '=',

  "GREATERTHAN" : (input) => input == '>',
  "LESSTHAN" : (input) => input == '<',
  "NOT" : (input) => input == '!',
  "GREATERTHANEQUAL" : (input) => input == '>=',
  "LESSTHANEQUAL" : (input) => input == '<=',
  "NOTEQUALTO" : (input) => input == '!=',
  "EQUALTO" : (input) => input == '==',

  "FATARROW" : (input) => input == '=>',

  "LPAREN" : (input) => input == '[',
  "RPAREN" : (input) => input == ']',
  "LBRACE" : (input) => input == '{',
  "RBRACE" : (input) => input == '}',
  "BAR" : (input) => input == ':',
  "COMMA" : (input) => input == ',',

  "SEMICOLON" : (input) => input ==';',
  "QUOTE" : (input) => input == "'",
  "DOT" : (input) => input =='.',

  "DECLARATOR" : (input) => input == '$',

  "NUMBER" : (input) => /^[0-9]+$/.test(input),
  "LETTER" : (input) => /^[a-zA-Z]+$/.test(input),
  "WHITESPACE" : (input) => !/\S/.test(input),

  "UNRECOGNIZED" : (input) => true,
};

const reserved = {
  "ikiwa" : 'FOR',
  "wakati" : 'WHILE',
  "rudisha" : 'RETURN',
  "andika" : "SHOW",
  "kama" : "IF",
  "au" : "ELSE",
  "kazi" : "FUNCTION",
};







class Log {
  constructor() {
    this.values = [];
  };

  add(log) {
    this.values.push({
      'log': log,
    });
  };

  error(e, ln) {
    this.values.push({
      'error' : {
        'message' : e.message,
        'line' : ln,
      }
    });
  };
  
  clear() {
    this.values = [];
    return this;
  };
};

let globalLog = new Log();


class BlockStmt {
  constructor(statement, environment) {
    this.statement = statement;
    this.body = this.fetchBody();
    this.parser = new Parser(environment);
    this.execute()
  };

  fetchBody() {
    return this.statement.slice(1, -1);
  };

  execute() {
    this.parser.load(this.body);
    this.statements = this.parser.parse();
  };
};

class PrintStmt {
  constructor(statement, evaluator, log) {
    this.log = log;
    this.statement = statement;
    this.expression = this.fetchExpression();
    this.evaluator = evaluator;
    this.value = null;
    this.execute();
  };

  fetchExpression() {
    return this.statement.slice(1);
  };

  execute() {
    this.evaluator.load(this.expression);
    this.value = this.evaluator.evaluate().value;

    if (this.value != undefined) {
      // console.log(this.value);
      this.log.add(this.value);

    } else {
      // console.log();
      this.log.add('');
    };
  };
};

class ExprStmt {
  constructor(statement, evaluator) {
    this.expression = statement;
    this.evaluator = evaluator;
    this.evaluator.load(this.expression);
    this.value = this.evaluator.evaluate().value;
  }
}

class DeclarationStmt {
  constructor(statement, evaluator, environment) {
    this.errorHandler = new ErrorHandler();
    this.statement = statement;
    this.evaluator = evaluator;
    this.environment = environment;

    this.value = null;
    this.identifier = statement[1].value;
    this.execute()
  };

  fetchValue() {
    let value = null;
    if (this.statement[2]) {
      if (this.statement[2].type == 'EQUALS') {
        let expression = this.statement.slice(3);
        this.evaluator.load(expression);
        value = this.evaluator.evaluate().value;
        if (value == undefined) {
          this.errorHandler.throw(
            'INVALID DECLARATION STATEMENT',
            this.statement[0].line,
            this.statement[0].col
          );
        };
      }
      else {
        this.errorHandler.throw(
          'INVALID DECLARATION STATEMENT',
          this.statement[0].line,
          this.statement[0].col
        );
      };
    };
    return value;
  };
    
  
  execute() {
      this.value = this.fetchValue();
      return this.environment.define(this.identifier, this.value);
  };
};

class IfStmt {
  constructor(statement, evaluator, environment) {
    this.evaluator = evaluator;
    this.parser = new Parser(environment);
    this.errorHandler = new ErrorHandler();

    this.statement = statement;

    this.expression = [];
    this.thenBlock = [];
    this.elseBlock = null;

    this.index = 1;
    this.currentToken = this.statement[this.index];
    this.prevToken = null;

    this.openingBrace = 0;
    this.closingBrace = 0;

    this.execute();
  };

  next() {
    this.prevToken = this.statement[this.index];
    this.index++;
    this.currentToken = this.statement[this.index];
    this.checkBrace();
  };

  checkBrace() {
    if (this.currentToken) {
      if (this.currentToken.type == 'LBRACE') {
        this.openingBrace++;
      };
      if (this.currentToken.type == 'RBRACE') {
        this.closingBrace++;
      };
    };
  };

  isInBlock() {
    return this.closingBrace != this.openingBrace;
  };

  splitBlock() {
    while (!this.isInBlock()) {
      this.expression.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '{' AFTER EXPRESSION`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
    };

    while (this.isInBlock()) {
      this.thenBlock.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '}' AFTER THEN BLOCK`,
          this.prevToken.line,
          this.prevToken.col
        );
      }
    };
    this.thenBlock.push(this.currentToken);
    this.thenBlock.push({
      type: 'SEMICOLON', 
      value: ';'
    });
    this.next();

    if (this.currentToken) {
      if (this.currentToken.type == 'ELSE') {
        this.next();
        if (this.isInBlock()) {
          this.elseBlock = [];

          while (this.isInBlock()) {
            this.elseBlock.push(this.currentToken);
            this.next();
            if (!this.currentToken) {
              this.errorHandler.throw(
                `EXPECTED '}' AFTER ELSE BLOCK`,
                this.prevToken.line,
                this.prevToken.col
              );
            };
          };
          this.elseBlock.push(this.currentToken);
          this.elseBlock.push({
            type: 'SEMICOLON', 
            value: ';'
          });
          this.next();
        }
        else {
          this.errorHandler.throw(
            `UNABLE TO PARSE ELSE STATEMENT`,
            this.prevToken.line,
            this.prevToken.col
          );
        };
      }
      else {
        this.errorHandler.throw(
          `UNEXPECTED KEYWORD AFTER IF STATEMENT`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
    };
  };

  execute() {
    this.splitBlock();

    this.evaluator.load(this.expression);
    let approve = this.evaluator.evaluate().value;

    if (approve) {
      this.parser.load(this.thenBlock);
      this.parser.parse();
    };
    if (!approve) {
      if (this.elseBlock) {
        this.parser.load(this.elseBlock);
        this.parser.parse();
      };
    };
  };
};

class WhileStmt {
  constructor(statement, evaluator, environment) {
    this.evaluator = evaluator;
    this.parser = new Parser(environment);
    this.errorHandler = new ErrorHandler();

    this.statement = statement;

    this.expression = [];
    this.body = [];

    this.index = 1;
    this.currentToken = this.statement[this.index];
    this.prevToken = null;

    this.openingBrace = 0;
    this.closingBrace = 0;

    this.execute();
  };

  next() {
    this.prevToken = this.statement[this.index];
    this.index++;
    this.currentToken = this.statement[this.index];
    this.checkBrace();
  };

  checkBrace() {
    if (this.currentToken) {
      if (this.currentToken.type == 'LBRACE') {
        this.openingBrace++;
      };
      if (this.currentToken.type == 'RBRACE') {
        this.closingBrace++;
      };
    };
  };

  isInBlock() {
    return this.closingBrace != this.openingBrace;
  };

  splitBlock() {
    while (!this.isInBlock()) {
      this.expression.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '{' AFTER EXPRESSION`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
    };

    while (this.isInBlock()) {
      this.body.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '}' AFTER BODY OF WHILE`,
          this.prevToken.line,
          this.prevToken.col
        );
      }
    };
    this.body.push(this.currentToken);
    this.body.push({
      type: 'SEMICOLON', 
      value: ';'
    });
    this.next()

    if (this.currentToken) {
      this.errorHandler.throw(
        `UNEXPECTED TOKEN AFTER WHILE STATEMENT`,
        this.currentToken.line,
        this.currentToken.col
      );
    };
  };


  execute() {
    this.splitBlock();
    let max = 1000;
    this.evaluator.load(this.expression);
    while (!!this.evaluator.evaluate().value) {
      this.parser.load(this.body);
      this.parser.parse();
      this.evaluator.load(this.expression);
      max--;
      if (max <= 0) {
        this.errorHandler.throw(
          `MAXIMUM NUMBER OF LOOPS EXCEEDED`
        );
        break;
      };
    };
  };
};

class FunctionStmt {
  constructor(statement, evaluator, environment) {
    this.evaluator = evaluator;
    this.environment = environment;
    this.errorHandler = new ErrorHandler();

    this.statement = statement;

    this.identifier = null;
    this.args = [];
    this.body = [];

    this.index = 1;
    this.currentToken = this.statement[this.index];
    this.prevToken = null;

    this.execute();
  };

  next() {
    this.prevToken = this.statement[this.index];
    this.index++;
    this.currentToken = this.statement[this.index];
  };

  splitBlock() {
    this.identifier = this.currentToken.value;
    this.next();
    if (!this.currentToken || this.currentToken.type != 'BAR') {
      this.errorHandler.throw(
        `EXPECTED '|' AFTER FUNCTION DECLARATION`,
        this.prevToken.line,
        this.prevToken.col
      );
    };
    this.next();

    while (this.currentToken && this.currentToken.type != 'BAR') {
      this.args.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '|' AFTER ARGUMENT LIST`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
      if (this.currentToken.type != 'COMMA' && this.currentToken.type != 'BAR') {
        this.errorHandler.throw(
          `EXPECTED ',' AFTER ARGUMENT`,
          this.prevToken.line,
          this.prevToken.col
        );
      }
      if (this.currentToken.type == 'BAR') {
        break;
      };
      this.next();
    };

    this.next();

    if (!this.currentToken || this.currentToken.type != 'FATARROW') {
      this.errorHandler.throw(
        `EXPECTED '=>' AFTER FN DECLARATION`,
        this.prevToken.line,
        this.prevToken.col
      );
    };
    this.next();

    this.body = this.statement.slice(this.index);
    this.body.push({
      type : 'SEMICOLON',
      value : ';',
    });
  };

  execute() {
    this.splitBlock();
    const zapFunction = new ZapFunction(
      this.identifier, 
      this.args, 
      this.body, 
      this.environment
    );
    this.environment.define(this.identifier, zapFunction);
  };
};

class Parser {
  constructor (environment) {
    this.environment = environment
    this.evaluator = new Evaluator(this.environment);
    this.errorHandler = new ErrorHandler();
    this.log = globalLog;


    this.tokens = null;
    this.index = null;
    this.currentToken = null;
    this.previousToken = null;

    this.statements = [];
    this.currentStatement = [];

    this.openingBrace = 0;
    this.closingBrace = 0;
  };

  load(tokens) {
    this.tokens = tokens;
    this.index = 0;
    this.currentToken = this.currentToken = this.tokens[this.index];
    this.previousToken = null;

    this.openingBrace = 0;
    this.closingBrace = 0;

    this.checkBrace();
  }

  resetCurrentStatement() {
    this.currentStatement = [];
  }

  checkBrace() {
    if (this.currentToken) {
      if (this.currentToken.type == 'LBRACE') {
        this.openingBrace++;
      };
      if (this.currentToken.type == 'RBRACE') {
        this.closingBrace++;
      };
    };
  };

  next() {
    this.index++;
    this.currentToken = this.tokens[this.index];
    this.previousToken = this.tokens[this.index-1];

    this.checkBrace();
  };

  isInBlock() {
    return this.openingBrace != this.closingBrace;
  };

  isSemicolon() {
    return this.currentToken.type == 'SEMICOLON';
  };

  handleBlock(statement) {
    let stmt = new BlockStmt(
      statement,
      new Environment(this.environment),
    );
    // console.log(stmt);
    return stmt;
  };

  handlePrint(statement) {
    let stmt = new PrintStmt(
      statement,
      this.evaluator,
      this.log,
    );
    // console.log(stmt);
    return stmt;
  };

  handleDeclaration(statement) {
    let stmt = new DeclarationStmt(
      statement,
      this.evaluator,
      this.environment,
    );
    // console.log(stmt);
    return stmt;
  };

  handleIf(statement) {
    // console.log(statement);
    let stmt = new IfStmt(
      statement,
      this.evaluator,
      this.environment
    );
    // console.log(stmt);
    return stmt;
  };

  handleExpression(statement) {
    let stmt = new ExprStmt(
      statement,
      this.evaluator,
    );
    // console.log(stmt);
    return stmt;
  };

  handleWhile(statement) {
    let stmt = new WhileStmt(
      statement,
      this.evaluator,
      this.environment
    );
    // console.log(stmt);
    return stmt;
  }

  handleFunction(statement) {
    let stmt = new FunctionStmt(
      statement,
      this.evaluator,
      this.environment
    );
    // console.log(stmt);
    return stmt;
  }

  handleStatement(statement) {
    // console.log(statement);
    if (statement[0].type == 'LBRACE') {
      return this.handleBlock(statement)
    };

    if (statement[0].type == 'SHOW') {
      return this.handlePrint(statement);
    };

    if (statement[0].type == 'DECLARATOR') {
      return this.handleDeclaration(statement);
    };

    if (statement[0].type == 'IF') {
      return this.handleIf(statement);
    };

    if (statement[0].type == 'WHILE') {
      return this.handleWhile(statement);
    };

    if (statement[0].type == 'FUNCTION') {
      return this.handleFunction(statement);
    };

    return this.handleExpression(statement);
  };

  parse() {
    while (this.currentToken) {
      if (!this.isInBlock())
      {
        if (!this.isSemicolon()) {
          this.currentStatement.push(this.currentToken);
        } else {
          let stmt = this.handleStatement(this.currentStatement);
          this.statements.push(stmt);
          this.resetCurrentStatement();
        };
        this.next()
        continue;
      } 
      else 
      {
        this.currentStatement.push(this.currentToken);
        if (!this.isInBlock()) {
          let stmt = this.handleStatement(this.currentStatement);
          this.statements.push(stmt);
          this.resetCurrentStatement();
        };
        this.next();
      };
    };

    if (this.currentStatement.length) {
      this.errorHandler.throw(
        'YOU MUST HAVE FORGOTTEN A SEMICOLON OR CLOSING BRACE',
        this.previousToken.line,
        this.previousToken.col
      );
    };

    return this.statements;

  };
};



class ZapFunction {
  constructor(name, args, body, environment) {
 

    this.errorHandler = new ErrorHandler();
    this.environment = new Environment(environment);
    this.parser = new Parser(this.environment);
    this.name = name;
    this.args = args;
    this.body = body;
    this.arity = args.length;
  };

  call(args) {
    if (args.length != this.args.length) {
      this.errorHandler.throw(
        `INVALID NUMBER OF ARGUMENTS PASSED TO ${this.name}`,
      )
    };

    for (let i=0; i < args.length; i++) {
      this.environment.define(this.args[i]['value'], args[i]);
    };
    
    this.parser.load(this.body);
    this.parser.parse();
  };
};










    
class Zap {
        constructor(input) {
            this.input = input;
            this.interpreter = new Interpreter(this.input);
        }
    }
    













 
 let tokens=[];
 function  tokenizer (input){
  
    
    let current=0;
    let tokens=[];
  
  
   
    
    while (current < input.length) {
    let char = input[current];
    if (/\s/.test(char)) {
    current++;
    continue;
    }
    
    const NUMBER_REGEX = /[0-9]|\./;
    if (NUMBER_REGEX.test(char)) {
    let value = '';
    while (NUMBER_REGEX.test(char)) {
    value += char;
    
    char = input[++current];
   
    }
  
    tokens.push({ type: 'number', value });
    continue;
    }
    
    const LETTER_REGEX = /#|[a-zA-Z_]|,.+=-*\//;
    if (LETTER_REGEX.test(char)) {
    let value = '';
    while (LETTER_REGEX.test(char) || char === '#') {
    value += char;
    char = input[++current];
    }
    
    if (value.startsWith('#')) {
    tokens.push({ type: 'variable', value: value.substring(1) });
    } else if (value==='tan'||value==='sin'||value==='cos'||value==='funga'||value==='fungua'||value==='Data'||value==='andika'||value==='thibitisha'||value==='prompti'||value==='kwakila'||value==='weka'||value==='mwisho'||value==='kwenye'||value==='tafuta'||value === 'kazi' || value === 'onesha' || value=='wakati'||value === 'ikiwa' || value === 'kama'||value=='namba'||value=='sentensi'||value=='wakati'||value=='Math'||value==='chukua'||value==='async'||value==='await'||value==='rudisha'||value==='vib') {
    
    tokens.push({ type: 'keyword', value });
    }
    else if (value==='++'||value==='--'||value==='*='||value==='-='||value==='/='){
    
    
    tokens.push({ type: 'DO', value });
    
    }
    
    
    
    
    else if (value === 'elementi') {
    
    tokens.push({ type: 'elementi', value });
    } else if (value === 'sikiliza') {
    tokens.push({ type: 'sikiliza', value });
    } else {
    
    tokens.push({ type: 'identifier', value });
    }
    
    continue;
    }
    
    const OPERATOR_REGEX = /[`\;\*\-\~\=\|.\:'!\+~|&#$@\-*/%?=,\\\(<>),{.#};" \""\_\n \[ \]]/;
    if (OPERATOR_REGEX.test(char)) {
    
    tokens.push({ type: 'operator', value: char });
    
    
    
    current++;
    continue;
    }
    
    
    throw new TypeError('Unknown character: ' + char );
    }
    
    return tokens;
    }
    
    
    
    
   
 
   
 
 
   
   
   
   
   
   
   
   
   
   
   
   
   function parser(tokens) {
    let current = 0;
    
    
    var ST={op:0,
    all:false,
    aa:false,
      
    };
    
    
    function parseExpression() {
    let token = tokens[current];
     
       if(tokens[current].type==='identifier' && tokens[current+1].value==='.'){
    
   
   //something like a.length;_bb.v;
   
   
   
   
      if (tokens[current].type === 'identifier' && tokens[current+1].value === '.'&&tokens[current+2].value!='weka') {
    let val=''
    
    while(tokens[current].value!=';'){
    
    val+=tokens[current].value
    current++;
    }
    
    
    current++
    
    return{type:'ObjCall',val}
    
    }
    
    
    
    
    
 
    let pushV=''
    let kwakila=''
    let Arrname=tokens[current].value;
    
    current+=2;
    
    if(tokens[current].type=='keyword'){
    
    
    if(tokens[current].value==='weka'){
    current+=2;
    
    while(tokens[current].value!=')'){
    pushV +=tokens[current].value;
    current++;
    }
    
    
    
    }
    else if(tokens[current].value==='kwakila'){
    
    kwakila=tokens[current].value;
    current+=2;
    
    while(tokens[current].value!=')'){
    pushV +=tokens[current].value;
    current++;
    }
    
    
    
    }
    
    
    
    
    
    
    
    
    }
    current+=1;
    
    
    return{type:'push',Arrname,pushV}
    }
    
    
    
  
    
   else  if(tokens[current].type==="identifier" && tokens[current+1].value==="["){
    
    
    let Arrname=tokens[current].value;
    let arrIndex='';
    let after=''
    current+=2;
    
    if(tokens[current].value!=']'){
    
    while(tokens[current].value!=']'){
    
    arrIndex +=tokens[current].value
    current++;
    
    }
    
    
    current++
    
   
    if(tokens[current].value==='='){
    current++
    while(tokens[current].value!=';'){
    
    after+=tokens[current].value;
    current++
    
    }
    current+=1
    
    }
   
    
    
 
    }
  
   
    
    return{type:'xx',Arrname,arrIndex,after}
    }
    
    
    
    
    
    
    
    
    
  else  if (tokens[current].type === 'number' || tokens[current].type === 'variable'||( tokens[current].type==='identifier' && tokens[current+1].value !="=" && tokens[current+1].value!='(')||tokens[current].type==='"') {
    
    
    let value=''
    if(token.value==='"'){
    value+='"'
    current++
    while(token.value !=='"'){
    value=tokens[current].value
    current++
    }
    value+='"'
    
    
    }
    value=tokens[current].value
    
    
    current+=1;
    
    return { type: 'Literal',value };
    
    
    } 
    
    
    

else  if(tokens[current].type==='identifier' && (tokens[current+1].value==='('||tokens[current+3].value==='(' &&tokens[current+2].type!='keyword')){

let args=''
let name=''

if(tokens[current+1].value==='('){
name=tokens[current].value;

current+=1;
if(tokens[current].value=='('){
current+=1;


 args=parseArgumentList()
current++
}}
else{
  while(tokens[current].value!='('){
    
    name+=tokens[current].value
    current++
  }
  current+=1
  args=parseArgumentList()
  current++
}
//current+=2;
//alert(tokens[current].value)
return{type:'funcCall',name,args}
}


    
    
 
    
else  if(tokens[current].type==='identifier' && (tokens[current+1].value==='+'||tokens[current+1].value==='-'||
tokens[current+1].value==='/'||
tokens[current+1].value==='%')){
  
  let body=''
  while(tokens[current].value!=';'){
    body+=tokens[current].value;
  current++
    
  }
  current++
  return{type:'math',body}
}
    
  
    
    
    
    
    
    
    
       else if(tokens[current].type==='identifier' && tokens[current+1].value==='{'){
    
    let ObjV=''
    let Objname=tokens[current].value;
    
    current+=1;
    
  
     
       
       
       
let body = ""
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
    
 body+=tokens[current].value
 current++
  }
  
  while (ST.op != 0) {
  
   if (tokens[current].value == "{") {
 ST.op+=1;
     body+=tokens[current].value
     current++
    }
    
    body+=tokens[current].value
    
    if (tokens[current].value == "}") {
      ST.op -= 1;
      
      
    }
    
  
  
    current++
  
  }
  
  
  
  if (ST.op === 0) {
   
       
       
       
       
       return{ type:'ObjData',Objname,body}}
    
    }
    
    
    
    
    //here thers modification buss
    
    
    else if(tokens[current].type==='identifier' && tokens[current+1].value==='='){
      
      
      
      let isFetch=false
      var p=false;
    let isAngle=false
    let angleName=''
   
    let v2='';let v1=tokens[current].value;
    current+=2;
    if(tokens[current].type=='identifier'||tokens[current].type==='elementi' ||tokens[current].type==='keyword'||tokens[current].type==="operator"||tokens[current].type==="number"){
      

      
      
    if((tokens[current].value==='cos')||(tokens[current].value==='sin')){
    isAngle=true;
    
    
    angleName=tokens[current].value;
  v2=parseExpression()
  
  
  
//  alert(v2)
  //alert(tokens[current].value)
  //remember to work with noe
  }
  else if(tokens[current].type=="keyword"&&tokens[current].value==='await'){
    isFetch=true
   
   //while(tokens[current].value!=";"){
    v2=parseExpression()
    
    current++
   // alert(tokens[current].value)
    v2=parseExpression()
    
    //current++
  // }
   // current++
  //  alert(tokens[current].value)
  // alert(v2.arg)
//alert(v22)
//v2=`${v2} ${v22 }`
}
  else{
  //current++
  
  if(tokens[current].value==='prompti'){
  p=true;
  v2=parseExpression()
  
  }
  if(tokens[current].value==='thibitisha'){
  
  v2=parseExpression()
  
  }
  
  
    while(tokens[current].value!=';'){
    
    v2+=tokens[current].value
    current++
    
   
    }
    
    current++
    
  }
    
 

    }
    
  
  //current+=1;


    return{type:'Assignment',v1,v2,isAngle,isFetch,angleName,p}
    }
    
    
    
    
    //above was a modification with no bound ****
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    //theres a modification above
    
    
    
    
    
    else if (token.type === 'keyword' &&(token.value === 'andika'||token.value === 'thibitisha' ||token.value === 'prompti'||token.value === 'onesha'||token.value === 'funga'||token.value === 'fungua')) {
    
    var met=tokens[current].value;
    current++;
    
    let expression=""
    let isString=false
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    
    current++;
   
   if(tokens[current].type=="operator" && tokens[current].value==='"'){
   
   
   expression=""
   isString=true;
   current++
   while(tokens[current].value!=='"'){
   
   expression+=tokens[current].value
   current++
   
   
   }
   current++
   
   }
    if(tokens[current].type==="identifier"){
    
  
   
    
    
    
    expression =parseExpression();
    
    
    }
    
    if(tokens[current].type==="number"){
    
    
    
    
    
    
    expression =parseExpression();
    
    
    }
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
 
    current+=1;
    
    if(met==='onesha'){
    
  return { type: 'PrintStatement', value:expression,isString};
    
    }else if(met==='andika'){
    
    
    
    return { type: 'andika', value:expression,isString};
    
    }else if(met==='thibitisha'){
    
    
    
    return { type: 'thibitisha', value:expression,isString};
    
    }else if(met==='prompti'){
    
    
    return { type: 'prompti', value:expression,isString};
    
    }
    else if(met==='funga'){
    
    
    return { type: 'funga', value:expression,isString};
    
    }
    else if(met==='fungua'){
    
    
    return { type: 'fungua', value:expression,isString};
    
    }
    
    
    
    } else {
    throw new SyntaxError('Missing closing parenthesis  ');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    }
    
    
    //#####here.   alert()  thers modification in this room###
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //#######some matha values has been added today#########
    
    else if (token.type === 'keyword' && token.value === 'namba') {
    
    
    current++;
    let value,name=tokens[current].value;
    
    current++;
    
    
    if(tokens[current].value=="="){
    
    current++;
    
    value=tokens[current].value
    
    }
    current+=1
    
    return {type:'_D',name,value}
    }
    
    
    //here there is modification
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'cos'|| tokens[current].value ==='sin'|| tokens[current].value ==='tan' ||tokens[current].value ==='randam') {
    
  
    let angle=tokens[current].value;
    
    let expression=""
    current++
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    
    if(tokens[current].type==="identifier"){
   
   
   
  while(tokens[current].value!=')'){
    expression+=tokens[current].value;
    current++
    
   }
   
    
    }
    
   
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    
    current+=1;
    //alert(tokens[current].value)
    return { type: 'mathAngle',angle,expression};
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    }
    
    
    
    
    else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    }
    
    
    
    
    
   
    
    
    
    
    
    
    
    
    
     
    
    
    
    
    
    
    
    
    
  
    else if (token.type === 'keyword' && token.value === 'Data') {
    
    
    current++;
    let value='';
    let name=tokens[current].value;
    
    current++;
    
    
    if(tokens[current].value=="{"){
    
    current++;
    
    while(tokens[current].value!='}'){
    
    
    value +=tokens[current].value
    
  current++;
    }
    
    current+=1;
    
    
        return {type:'Obj',name,value}
    }
    
    
    
    
else if(tokens[current].value=="[" && tokens[current +1].value==="]"){
    
    current+=2;
    
    
    return {type:'Arr',name}
    }
    







    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if (token.type === 'keyword' && token.value === 'sentensi') {
    current++;
    let name=tokens[current].value;
    let string=""
    current++;
    
    let value
    if(tokens[current].value=="="){
    
    current++;
    }
    
    value=tokens[current].value
    
    
    if (value === '"') {
    
    current++
    
    
    while (tokens[current].value !== '"') {
    string += tokens[current].value
    
    
    current++
    
    }
    
    
    current+=1
    
    
    
    }
    
    
    return {type:'v',name:name,string}
    }
    
    
    
    //here theres modification
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if (token.type === 'elementi' && token.value === 'elementi') {
    
    var isD=false
    
    
    
    
    
    
    let elementMethod= token.value;
    current++
    if(tokens[current].value=="("){
    current++;
    
    
    
    let value=tokens[current].value
    
    
    
    if (value === '"') {
    
    
    let string = '';
    let selectorType=''
    
    while (tokens[current++] !== ',') {
    
    selectorType += tokens[current].value;
    
    
    
    break;
    
    }
    
    
    current+=1
    
    while (tokens[current++] !== '"' && tokens[current].value!=',') {
    
    string += tokens[current].value;
    
    
    
    break;
    
    
    
    }
    
    
    let strin,body,args
    
    let method=tokens[current + 3].value
    
    if(method=="."){
    current+=4;
    let methods=tokens[current].value
    
    
    if(tokens[current].value=='stailiRangi'||'kontentiNdani'||'kontenti'||'stailiRangiElementi'||'stailiUre'||'stailiUp'||'stailiMwonekano'||'sikilizaTukio'||'choraMstari'||'lineTo'||'kanvaStaili'||'kanvaMstatili'||'kanvaManeno'||'kontexti'||'kanvaFonti'||'kanva' ){
    
    let valuex =tokens[current+2].value;
    if(valuex.startsWith('"')){
   current+=3;
   
   while(tokens[current].value!='"'){
   
   valuex +=tokens[current].value
   current++;
  
   }
   valuex +='"'
  
    isD=true;
    }
    
    if(tokens[current].value=='sikilizaTukio'){
    current+=2;
    
    let value=tokens[current].value
    
    let event="";
    if (value === '"') {
    
    while (tokens[current++] !== ',') {
    
    event+= tokens[current].value;
    
    
    
    break;
    
    }
    
    
    
    current+=1
    
    
    
    
    while (tokens[current++] !== '"' && tokens[current].value!=',') {
    
    
    
    
    break;
    
    
    
    }
    
    current++
    
    strin=tokens[current].value
    if(strin=="kazi"){
    current+=2;
    
    args=parseArgumentList()
    current+=1;
    
    
    
    
    
    
let body = []
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
  }
  
  while (ST.op !== 0) {
  
    if (tokens[current].value == "{") {
  
      body.push(parseExpression())
      current++
    }
 
    body.push(parseExpression())
    if (tokens[current].value == "}") {
      ST.op -= 1;
      body.push(parseExpression())
      current++
    }
    //  
  
  
    //current++
  
  }
  
  
  
  if (ST.op === 0) {
    //alert(body)
  
 
  
  
    
    }
    
    
    
    
    
    current+=2;
  //  alert(isD)
    return {type:'elem',selectorType,args,body,event,string}
    
    }
      
      
    }}
    
    
    else if(tokens[current].value==="kontexti"){
      let m=''
      let cv=""
      let mv=""
      current+=2
      while(tokens[current].value!=')'){
        cv+=tokens[current].value
        
        current++
        
      }
      current+=2
      
      if(
        tokens[current].value==='kanvaMstatili'
      ||
        tokens[current].value==='kanvaStaili'
      
      ||
        tokens[current].value==='kanvaText'
      
      ||
        tokens[current].value==='jaza'
      
     ||
        tokens[current].value==='kanvaFonti'
      ||tokens[current].value==='kanvaManeno'
      
      ){
        m=tokens[current].value
        
        current+=2
        while(tokens[current].value!=')'){
          
          mv+=tokens[current].value
          
          current++;
          
        }
        current++
        
        
        
        
       
        
       
      }
      
      
      
      
      
      
      
      
      
      
      
      
      
      
       
        return{type:'canva',cv,mv,m,selectorType,string}
        
      
      
    }
    
    
    
    
    
    
    
    
    
    
    else{
    if(isD){
   
    current+=1}else{current+=3;}
   
   
    
   if(tokens[current].value==')'){
   
  
    current++
  
  
    
    return { type:'Elementi',selectorType,string,methods,valuex,isD}
    
   } } 
    
    
    
    }
    
    
    else{
    
    
  
  
    
    
    return{   type:'El',selectorType,string,}
    
    
    }
    
    
    }
    
    
    
    }
    
    
    
    
    }
    
    }
    
    
    
   
    
    
    
    else if (token.type === 'keyword' && token.value === 'kazi') {
    
  
    current++;
    if (tokens[current].type === 'identifier') {
    let functionName = tokens[current].value;
    current++;
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    let arguments = parseArgumentList();
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    current+=1;
    
    

    
    
    
    
    
    
let body = []
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
  }
  
  while (ST.op !== 0) {
  
    if (tokens[current].value == "{") {
  
      body.push(parseExpression())
      current++
    }
 
    body.push(parseExpression())
    if (tokens[current].value == "}") {
      ST.op -= 1;
      body.push(parseExpression())
      current++
    }
    //  
  
  
    //current++
  
  }
  
  
  
  if (ST.op === 0) {
    //alert(body)
  
 
  
  

    
    
    
    
    
    return { type: 'FunctionDeclaration', name: functionName, arguments,body }};
   
   
   
   
   
   
   
   
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    } else {
    throw new SyntaxError('Missing function name');
    }
    }
    
    
    
    
    
        else if (tokens[current].type === 'keyword' && tokens[current].value === 'async') {
    let val=tokens[current].value
    current++
    return{type:'async',val}
          
        }
    
    
    
    
        else if (tokens[current].type === 'keyword' && tokens[current].value === 'await') {
          
    let val=tokens[current].value
    
    return{type:'await',val}
          
        }
    
    
    
    
    
        else if (tokens[current].type === 'keyword' && tokens[current].value === 'rudisha') {
         
          current++
          var val=""
          if(tokens[current].type==='operator'&&tokens[current].value==="{"){
            while(tokens[current].value!='}'){
    val+=tokens[current].value
            current++
            }
            val+=tokens[current].value
          current++
           // alert(val)
          }else if(tokens[current].type==='identifier'){
            val=tokens[current].value
          
          
    current+=2
            
          }
    //alert(tokens[current].value)
 //  alert(val)
    return{type:'return',val}
          
        }
    
    
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'chukua') {
    
    current++
    if(tokens[current].type==='operator' && tokens[current].value==='('){
   var arg=""
    current++
    while(tokens[current].value!==';'){
    arg=parseArgumentList()
    current++
    }
    }
    
    
  current++
  
    return{type:'fetch',arg}
    
    
    
    
    }
    
    
    
    
   ///here
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  
    
  
    
  else if ( tokens[current].value == '{') {
   let v=''
    if(ds.ax){
      v=':'
    }else{
    
    v = tokens[current].value}
    
    return { type: 'opbrace', v }
  
  }
    else if(tokens[current].value=='}'){
     
     let v=''
      if(ds.ax){
        v='break;'
      }else{
        v=tokens[current].value}
     
      return{type:'clbrace',v}
    }
    
    
    
    else if (token.type === 'keyword' && token.value === 'ikiwa') {
      
    current++;
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current+=2
    
  
    let initName=""
    while(tokens[current].value!=";"){
      initName+=tokens[current].value;
      current++
    }
    
    
   
    
    
    
    let initialization=initName;
    
    
    
    
    current+=1
    let condition=""
    while(tokens[current].value!==';'){
  
    condition += tokens[current].value;
    
    
    current++}
    
    current+=1
    let update =""
    while(tokens[current].value!==')'){
    
    
    update+=tokens[current].value
    current++}
    
    
    
    
    
    
    
    
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    current+=1;
    let body=[]
    let ST={op:0};
if(tokens[current].value==='{'){
  ST.op+=1;
}
    
   while(ST.op!==0){
     
     if (tokens[current].value == "{") {
       
           body.push(parseExpression())
        current++ }
        
     body.push(parseExpression())
     if(tokens[current].value=="}"){
       ST.op-=1;
       body.push(parseExpression())
       current++
   }
   //  

  
  //current++
   
   }
      
   
   
   if(ST.op===0){
    //alert(body)
    return { type: 'for',initialization,condition,update,body };}
    } 
    
    
    else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    }
    
    
    
    
    
    
    
    
    
    else if (token.type === 'keyword' && token.value === 'wakati') {
    let body=""
    current++;
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    
    
    
    let condition =""
    
    while(tokens[current].value!==')'){
    
    condition +=tokens[current].value
    current++}
    
    
    
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    current+=1;
    
    
    
    let body=[]
    let ST={op:0};
if(tokens[current].value==='{'){
  ST.op+=1;
}
    
   while(ST.op!==0){
     
     if (tokens[current].value == "{") {
       
           body.push(parseExpression())
        current++ }
        
     body.push(parseExpression())
     if(tokens[current].value=="}"){
       ST.op-=1;
       body.push(parseExpression())
       current++
   }
   //  

  
  //current++
   
   }
      
   
   
   if(ST.op===0){
    //alert(body)
   
    
    
    return { type: 'while', condition, body };
   
   }
   
   
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    } 
    
    
    
    
    
    
    
    
    
    
    
    else if (token.type === 'operator' && token.value === '(' && tokens[current+1].value!==')' && ST.all===true) {
   
    current+=1
    
    let condition=''
    while(tokens[current].value!=')'){
    condition+=tokens[current].value
    
    current++
    }
    
   // current+=1
   
  
    current++
    
    
    let body = []
    let ST = { op: 0 };
    if (tokens[current].value === '{') {
      ST.op += 1;
    }
    
    while (ST.op !== 0) {
    
      if (tokens[current].value == "{") {
    
        body.push(parseExpression())
        current++
      }
      
      body.push(parseExpression())
      if (tokens[current].value == "}") {
        ST.op -= 1;
        body.push(parseExpression())
        current++
      }
      //  
    
    
      //current++
    
    }
    
    
    
    if (ST.op === 0) {
      //alert(body)
    
    
    
    
    
    
    
    
    return{type:'ElseIf',body,condition}}
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  /*  
    
    else if (tokens[current].type === 'operator' ) {
    
    current++
    }
    
    */
    
    
    
    
    
    
    
    
    
    
    
    
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if (tokens[current].type ==="operator" && tokens[current].value==="(" &&tokens[current+1].value===')' && ST.all===true) {
    
   current+=2;
    
    
    let body = []
    let ST = { op: 0 };
    if (tokens[current].value === '{') {
      ST.op += 1;
    }
    
    while (ST.op !== 0) {
    
      if (tokens[current].value == "{") {
    
        body.push(parseExpression())
        current++
      }
     
      body.push(parseExpression())
      if (tokens[current].value == "}") {
        ST.op -= 1;
        body.push(parseExpression())
        current++
      }
      //  
    
    
      //current++
    
    }
    
    
    
    if (ST.op === 0) {
     
    
    ST.all=false;
    
    
    return{type:'Else',body}}
    }
    
    
    
    
      else if (tokens[current].type === 'keyword' && tokens[current].value === 'kwenye'|| tokens[current].value === 'mwisho') {
 let a_=tokens[current].value
 if(a_=='kwenye'){
   a_='case'
 }
      else{
        a_='default'
      }
    current++
    let a=''
    while(tokens[current].value!=':'){
      a+=tokens[current].value
      current++
      
  
    }
    
    return{type:'case',a,a_}
    
      }
      
     
    
    
    
    
    
    
    
      else if (tokens[current].type === 'operator' && tokens[current].value === ':') {
        
       
       current++
      
    
    
    
    
    
      let body = []
      let ST = { op: 0 ,};
      if (tokens[current].value === '{') {
        
        ST.op += 1;
      }
      
      while (ST.op !== 0) {
      
        if (tokens[current].value == "{") {
     ds.ax=true
          body.push(parseExpression())
          current++
        }
        //alert(tokens[current].value)
        body.push(parseExpression())
        if (tokens[current].value == "}") {
          ST.op -= 1;
          ds.ax=true
          body.push(parseExpression())
          current++
        }
        //  
      
      
        //current++
      
      }
      
      
      
      if (ST.op === 0) {
        //alert(body)
     // alert(ds.ax)
      ds.ax=false
   
      
        return { type: 'todo',body}
    
    
    
    
    
    
    
    
      }
      
      
      }
      
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'tafuta') {
      
      current+=2
      let condition=''
      while(tokens[current].value!=')'){
        condition+=tokens[current].value;
        current++
        
        
      }
      
     
      current+=1;
      
      
      
      let body = []
      let ST = { op: 0,};
      if (tokens[current].value === '{') {
        
        ST.op += 1;
      }
      
      while (ST.op !== 0) {
      
        if (tokens[current].value == "{") {
      
          body.push(parseExpression())
          current++
        }
        //alert(tokens[current].value)
        
        body.push(parseExpression())
        if (tokens[current].value == "}") {
          ST.op -= 1;
          body.push(parseExpression())
          current++
        }
        //  
      
      
        //current++
      
      }
      
      
      
      if (ST.op === 0) {
        
      
      
      
      
        return { type: 'switch', condition, body }
      };
      
      
      
    }
    
    
    
    
    
    
    
    else if (token.type === 'keyword' && token.value === 'kama') {
    ST.all=true;
    current++;
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    
    
    
    let condition =""
    while(tokens[current].value!==')'){
    
    condition +=tokens[current].value
    current++
    }
    
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
   
    current+=1;
  
        
  // alert(condition)
  
  
let body = []
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
  }
  
  while (ST.op !== 0) {
  
    if (tokens[current].value == "{") {
  
      body.push(parseExpression())
      current++
    }
// alert(tokens[current].value)
    body.push(parseExpression())
    if (tokens[current].value == "}") {
      ST.op -= 1;
      body.push(parseExpression())
      current++
    }
    //  
  
  
    //current++
  
  }
  
  
  
  if (ST.op === 0) {
    //alert(body)
  
 
  
  
    return { type:  'IfStatement', condition:condition,body}};
    
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    } 
    
    
    
    
    
 
    
    
    
    
    else {
    throw new SyntaxError('Unexpected token: ' + token.value);
    }
    
    
    
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    function parseArgumentList() {
    let arguments = [];
    
    while (tokens[current].type === 'identifier') {
    arguments.push(tokens[current].value);
    current++;
    if (tokens[current].type === 'operator' && tokens[current].value === ',') {
    current++;
    } else {
    break;
    }
    }
   // current++
    
    return arguments;
    }
    
    
    
    
    var ds={ax:false}
    
    
    
    
    
    
    
    
    function parseStatements() {
    let statements = [];
    
    
    while (current < tokens.length) {
    
    if (tokens[current].type === 'keyword' && tokens[current].value === 'onesha') {
    
    statements.push(parseExpression());
    }
    
    else if (tokens[current].type === 'DO') {
    
    statements.push(parseExpression());
    }
    
    
    
     
    
    
    
    else if (tokens[current].type === 'variable') {
    
    statements.push(parseExpression());
    }
    else if (tokens[current].type === 'identifier' && tokens[current+1].value==='.') {
    statements.push(parseExpression());
    }
    else if (tokens[current].type === 'identifier') {
    statements.push(parseExpression());
    }
    
    else if (tokens[current].value==='mwisho') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type==='operator'&&tokens[current].value===':') {
    statements.push(parseExpression());
    }
    else if ( tokens[current].type==='keyword' && tokens[current].value==='Data') {
    statements.push(parseExpression());
    }
    
    
    else if ( tokens[current].type==='keyword' && tokens[current].value==='kwenye') {
    statements.push(parseExpression());
    }
    
    
    
    
else  if(tokens[current].type==='identifier' && (tokens[current+1].value==='+'||tokens[current+1].value==='-'||
tokens[current+1].value==='/'||
tokens[current+1].value==='%')){
      statements.push(parseExpression());
    
    }
    
  
    
    
    else if(tokens[current].type=="identifier" && tokens[current +1].value=="["){
    
    
    statements.push(parseExpression());
    
    }
    
    
    
    else if (tokens[current].type === 'identifier' && tokens[current+1].value=='(') {
   
    statements.push(parseExpression());
    
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(tokens[current].type=='operator'&& tokens[current].value=='}'){
     
        statements.push(parseExpression());
      
    }
    
    
    else if(tokens[current].type=='operator'&& tokens[current].value=='{'){
     
        statements.push(parseExpression());
      
    }
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'fungua') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'funga') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'prompti') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'andika') {
    statements.push(parseExpression());
    }
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'fungua') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'thibitisha') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'kazi') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value==='chukua') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'elementi' && tokens[current].value === 'elementi') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'sikiliza' && tokens[current].value === 'sikiliza') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'tafuta') {
    statements.push(parseExpression());
    }
    
    
    
    
    
      else if (tokens[current].type === 'keyword' && tokens[current].value === 'kwenye'|| tokens[current].value === 'mwisho') {
            statements.push(parseExpression());
    }
    
 
    
      else if (tokens[current].type === 'operator' && tokens[current].value === ':') {
            statements.push(parseExpression());
    }
    
      
    

    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'namba') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'wakati') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'number') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'sentensi') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'sin') {
    statements.push(parseExpression());
    } 
    else if (tokens[current].type === "operator" && tokens[current].value === "(" && tokens[current + 1].value != ')' && ST.all === true) {
      statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type ==="operator" && tokens[current].value==="(" &&tokens[current+1].value===')' && ST.all===true) {
      
  statements.push(parseExpression());}
   
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'cos') {
    statements.push(parseExpression());
    } 
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'await') {
    statements.push(parseExpression());
    } 
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'async') {
    statements.push(parseExpression());
    } 
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'rudisha') {
    statements.push(parseExpression());
    } 
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'ikiwa') {
    statements.push(parseExpression());
    } 
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'kama') {
    statements.push(parseExpression());
    } else {
    throw new SyntaxError('Unexpected token: ' + tokens[current].value);
    }
    }
    
    return statements;
    
    
    
    }
    
    
    return parseStatements();
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    function generateCode(ast) {
    
    
    let code = '';
    
    let cu=0;
    function traverse(node) {
    
   
  
    
    if(node.type=="Literal"){
    
   
    
    let a=`  ${node.value}  \n`
    return code=node.value;
    
    
    }
    
    
    
    else if(node.type=="thibitisha"){
    
    if(node.isString){
    
    cu++
    return code=`  confirm("${node.value}");`
    }else{cu++
    
    return code=` confirm(${node.value.value});`;
    
    }
    
    }
    
    
    
    else if(node.type=="fungua"){
    
    if(node.isString){
    
    cu++
    return code=`  window.open("${node.value}");`
    }else{cu++
    
    return code=` window.open(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    else if(node.type=="funga"){
    
    if(node.isString){
    
    cu++
    return code=`  window.close("${node.value}");`
    }else{cu++
    
    return code=` window.close(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    else if(node.type=="andika"){
    
    if(node.isString){
    
    cu++
    return code=`  document.write("${node.value}");`
    }else{cu++
    
    return code=` document.write(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    
    
    
    
    else if(node.type=="prompti"){
    
    if(node.isString){
    
    cu++
    return code=`  prompt("${node.value}");`
    }else{cu++
    
    return code=` prompt(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    
    
    
    
    
    else if(node.type=="PrintStatement"){
     
    if(node.isString){
    
    cu++
   return code=`  alert("${node.value}");`
    }else{cu++
   
return code=` alert(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    
    
    
   else if(node.type=="xx"){
   let a= node.Arrname
   let b=node.arrIndex
   let c=node.after
   
     cu++
   
    return  code=`${a}[${b}]=${c};\n`
    
     
    }
    
    
    
    
    
    else if(node.type==="math"){
     
      let z=node.body+'\n';
        
         return code=z
      }
      
      
    
    
    
    
    
    else if(node.type=="Obj"){
    
    
    let x=node.name
    let y=node.value
    cu++
    let z=`  ${x} ={ ${y} };\n`
    
    return code=z
    
    
    }
    
    
    
    else if(node.type=="Arr"){
    
    
    let x=node.name
    
    let z=`const ${x} =[];\n`;
    
    cu++
    return code=z;
    
    
    }
    
    
    else if(node.type=="ObjCall"){
    
    
    let x=` \n ${node.val}  `
    
    
    
    cu++
    
    return code=x;
    
    
    }
    
    
    
    else if(node.type=="push"){
    
    
    let x=node.Arrname
    let y=node.pushV;
    
    let z=`${x}.push(${y});\n`;
    
    return code=z;
    
    
    }
    
    
    
    
    else if(node.type=="Assignment"){
    let c=''
    let z=''
    let y=''
    
    let x=node.v1
     
    
    
    
    if(node.isFetch){
     
    
    y=`  ${node.v1}=${traverse(node.v2)}  ;\n`
      
     return code=y
    }
    

    if(node.isAngle){
      
      
      
    let y=node.v2.expression
    let a=node.angleName
    z=`${x}=Math.${a}(${y}); \n`
    
    
    }
    else{
    
    if(node.p){
    c = traverse(node.v2)
    
    
    
    y=c;
    
    z=`${x}=${y} \n`
    
    return code=z
    }
    else if(!node.p){
    
   
    c = node.v2
    
    y=c;
    
    z=`${x}=${y}  \n`
    return code=z
    }
    
   
    y=node.v2
    
     z=`${x}=${y};  \n`
     }
     cu++
     
    return code=z;
    
    
    }
    
    
    
    
    else if(node.type=="mathAngle"){
    
    
    let x=node.angle
    let y=node.expression
    
    let z=`Math.${x}(${y});\n`
   
    return code=z;
    
    
    }
    
   
   
   
   
   
   
   
   
   
   
   
   
   
    else if(node.type=="switch"){
     
     let d=node.condition
     let a = 0
     let c = ''
     
     function xyz() {
       //traverse(ast[a])
     
       c += traverse(node.body[a])
       // alert(c)
     }
     while (a < node.body.length) {
     
       xyz()
       a++
     
     }
     
     
     let co=`switch(${d}) ${c}`
     
     
     
     
      return code =co
    }
    
    
   
   
   
   
   
   
   
    else if(node.type=="case"){
     let d=`${node.a_} ${node.a}`
      return code =d
    }
    
   
   
   
    else if(node.type=="todo"){
     
     
     
    
     let a = 0
     let c = ''
     
     function xyz() {
       //traverse(ast[a])
     
       c += traverse(node.body[a])
       // alert(c)
     }
     while (a < node.body.length) {
     
       xyz()
       a++
     
     }
     
     
      return code =c
    }
    
   
   
   
    else if(node.type=="fetch"){
     
     
     
   return code =`await fetch(${node.arg})`
    
    }
    
    
    else if(node.type=="async"){
     
     
     
      return code =` ${node.val}   `
    }
    
    
    
    else if(node.type=="await"){
     
   
     
      return code =`     ${node.val}   `
    }
    
    else if(node.type=="return"){
     
     
     
      return code =`return  ${node.val} \n`
    }
    
    
    
    
    else if(node.type=="opbrace"){
     
     
     
      return code =`${node.v}\n`
    }
    
    
    
    else if(node.type=="clbrace"){
     
      return code =`${node.v}\n`
    }
    
    
    
    else if(node.type=="_D"){
    
  
    
    return  code=`
    var ${node.name} =${node.value};\n`;
    
    
    }
    else if(node.type=="v"){
    
   
    
    return code=`var ${node.name} ="${node.string}";\n`;
    

    }
    
    
    
    else if(node.type=="FunctionDeclaration"){
    

let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
  
     
    return code = `function ${node.name}(${node.arguments.join(', ')}) ${c}\n`;
    
    }
    
    
    else if(node.type=="funcCall"){
    
   return code = ` ${node.name}(${node.args});\n`
   
    
    }
    
    
    
    
    
    
    else if(node.type=="IfStatement"){
    
    
    
    
    
    
    

let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
   
    
    
    
    
    
    return   code = `    \n if (${node.condition}) ${c}     \n`;
   
   
   
    }
    
    
    
    
    
    
    
    
    else if(node.type=="Else"){
    
let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
    
    return  code =` else ${c}\n`;
    }
    
    
    
    
    else if(node.type=="ElseIf"){
    
    
    
let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
    
    
    
    return code = `else if(${node.condition})${c}  `;
    
    
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(node.type=="while"){
    
    
      let v= `while (${node.condition})`
      

    let a=0
    let c=''
    function xyz(){
      //traverse(ast[a])
      
      c+=traverse(node.body[a])
     // alert(c)
}
    while(a<node.body.length){
      
      xyz()
      a++
      
    }
    
   let b=`${v}${c} \n`
   return c=b;
    }
    
    
    
    /*
    else if(node.type=="fetch"){
    
    return code+= `fetch(${node.url}, {
    method: '${node.method}',
    headers:${node.meta},
    body: JSON.stringify(${node.body})
    })
    .then(${node.args}=> ${node.res}).then(${node.args2}=> {
    
    ${node.res2}
    })`
    
    
    
    
    
    
    }
    */
    
    
    
    
    
    
    
    else if(node.type==='canva'){
    //  alert(node.string)
    let z=""
    let s=false
     let a=`document.querySelector("#${node.string}")`
     let b=''
    if (node.m==='kanvaStaili'){
      b='fillStyle'
      s=true
    }else if(node.m==='jaza'){
      b='fill'
    }else if(node.m==='kanvaFonti'){
      
      
      b='font'
      s=true
    }else if(node.m==='kanvaManeno'){
      
      
      b='fillText'
   
    }else if(node.m==='kanvaMstatili'){
      
      
      b='fillRect'
    }else{}
    
    
    if(s){
      
      
      z=`${a}.getContext(${node.cv}).${b}=${node.mv};\n`
      
    }else{
      
      z=`${a}.getContext(${node.cv}).${b}(${node.mv});\n`
      
    }
    
    
  //  alert(b)
 //    alert(z)
     return code=z
     
    }
    
    
    
    
    else if(node.type=="Elementi"){
    
    let m=node.methods
    
    let v=""
    v=node.valuex;
    
    
    let sel =node.selectorType;
    
    
    
    
    if(sel=="id"){
    let res=""
    if(m=="stailiRangi"){
    
    res  ='style.color ='
    
    }
    else if(m=="stailiRangiElementi"){
    res='style.backgroundColor='}
    else if(m=="stailiUre"){
    res='style.height='}
    else if(m=="stailiUp"){
    res='style.width='}
    
    else if(m=="stailiMwonekano"){
    res='style.display='
    if(node.value=="onekana"){
    v=" "}
    if(node.value=="usionekane"){
    v="none"
    }
    }
    else if(m=="kontentiNdani"){
    
    
    res='innerHTML='  }
    else if(m=="kontenti"){
    res ='value'}
    else if(m=="sikilizaTukio"){
    
    }else {}
    
    if(m =="kontentiNdani"){
    
    
    
    
       return code = `document.querySelector("#${node.string}").${res}${v};`;
    
    
  
    
    }else{
    
    return code +=`document.querySelector("#${node.string}").${res} "${v}";`;}
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(sel=="class"){
    let res=""
    if(m=="stailiRangi"){
    
    res  ='style.color ='
    
    }
    else if(m=="stailiRangiElementi"){
    res='style.backgroundColor='}
    else if(m=="stailiUre"){
    res='style.height='}
    else if(m=="stailiUp"){
    res='style.width='}
    
    else if(m=="stailiMwonekano"){
    res='style.display='
    if(node.value=="onekana"){
    v=" "}
    if(node.value=="usionekane"){
    v="none"
    }
    }
    else if(m=="sikilizaTukio"){
    
    }
    
    
    
    
    
    
    else if(m=="konteniNdani"){
    res='innerHTML='}
    else if(m=="kontenti"){
    res ='value'}else{
    }
    
    
    
    return   code = `document.querySelector(".${node.string}").${res}"${v}"`;
    
    }
    else if(sel=="name" ){
    
    let res=""
    if(m=="stailiRangi"){
    
    res  ='style.color ='
    
    }
    else if(m=="stailiRangiElementi"){
    res='style.backgroundColor='}
    else if(m=="stailiUre"){
    res='style.height='}
    else if(m=="stailiUp"){
    res='style.width='}
    
    else if(m=="stailiMwonekano"){
    res='style.display='
    if(node.value=="onekana"){
    v=" "}
    if(node.value=="usionekane"){
    v="none"
    }
    }
    else if(m=="konteniNdani"){
    res='innerHTML +='}
    else if(m=="kontenti"){
    res ='value'}else{
    }
    
    
    return   code = `document.querySelector("${node.string}").${res}${v}`;
    
    }
    
    
    }
    
    else if(node.type=="elem"){
      
      
    if(node.selectorType=="id"){
    
    
    
    

let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
   
    
    
    
    
    
    
    
    
    
    
    return code =`document.querySelector("#${node.string}").addEventListener("${node.event}", function(${node.args.join(', ')}) ${c})`;
    }  }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(node.type==='ObjData'){
      
      
      
      
      
   
   
      
      
      
      
     return code=`${node.Objname}=${node.body};\n`
     
    }
    
    
    
    else if(node.type=="for"){
     // alert('im')
   let x=node.initialization
   
   let y=node.condition
   let z=node.update
   
   
let a = 0
   let c = ''
   
   function xyz() {
     
     //traverse(ast[a])
     
   
     c += traverse(node.body[a])
   
     
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
   
   
   
   
 
    cu++
  return  code=`for( var ${x};${y};${z})
      ${c}
   
  \n  `
      
      
    }
    
    
    
    
    
    
    
    
    
    else{
    
    
    // throw new Error('Unknown construct '+ 
    node.value
    
    }
    
    }
    let a=0
    let c=''
    function xyz(){
      //traverse(ast[a])
      
      c+=traverse(ast[a])
     // alert(c)
}
    while(a<ast.length){
      
      xyz()
      a++
      
    }
    
    
    return code=c}
    
  
    
    

  //document.getElementById("donut").innerHTML=day
   /* i.forEach(c=>{
      
      alert(c.type)
    })*/
    
    
    
    
    



        function Compile() {
            var inp = editor.getValue(); // Get value from CodeMirror

            // Timing the compile process
            
                
    var d=new tokenizer(inp)
    var i= new parser(d)
  var day=generateCode(i);
// console.log(day)
var kiswahiliScript=  Function(day)
 
 kiswahiliScript()
 
        }

        // Handle file creation form
        document.getElementById('fileForm').addEventListener('submit', function(event) {
            event.preventDefault();
            var fileName = document.getElementById('fileName').value;
            createFile(fileName);
        });

        // Modal functionality
        function openModal() {
            document.getElementById('fileModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('fileModal').style.display = 'none';
        }
        
        
        
        
        function toggleTerminal() {
    var editorContainer = document.getElementById('editorContainer');
    var terminalContainer = document.getElementById('terminalContainer');

    if (terminalContainer.classList.contains('hidden')) {
        editorContainer.classList.add('hidden');
        terminalContainer.classList.remove('hidden');
        document.getElementById('terminalInput').focus();
    } else {
        terminalContainer.classList.add('hidden');
        editorContainer.classList.remove('hidden');
    }
}

var isDone=false;
function executeCommand(command) {
    const terminalOutput = document.getElementById('terminalOutput');
    const args = command.trim().split(/\s+/);
    const cmd = args[0];
    const filename = args[1];

    if (cmd === 'kiswahili') {
        switch (args[1]) {
            case 'clear':
                terminalOutput.innerHTML = '';
                break;
            case 'mkfile':
                createFile(args[2]);
                terminalOutput.innerHTML += '> File created\n';
                break;
                
                
                case  'run':
                  if(!isDone){
                    terminalOutput.innerHTML+='><span>huez ku run program bila ku compail '
                  }
                  if(isDone){
                compile();
                 
                  }
            
            break;
            case 'compail':
              terminalOutput.innerHTML += '> Compilation successful\n';
              isDone=true;
              setTimeout(function(){
                terminalOutput.innerHTML += '> <br>..';
                
              },1000)
              setTimeout(function(){
                terminalOutput.innerHTML += ' .......';
                
              },1000)
              
              setTimeout(function(){
                terminalOutput.innerHTML += '> now run your program\n';
                
              },1000)
             
              break;
              
              
            case 'delete':
              delete files[filename];
            terminalOutput.innerHTML += '> File deleted\n';
            updateFileList();
            break;
              
                  
            default:
                if (args[1].endsWith('.kiss')) {
                    handleFileCommands(args[1], args[0]);
                } else {
                    terminalOutput.innerHTML += '> Unknown command\n';
                }
        }
    } else {
        terminalOutput.innerHTML += '> Unknown command\n';
    }

    // Scroll to the bottom of the terminal output
    terminalOutput.scrollTop = terminalOutput.scrollHeight;
}

function handleFileCommands(filename, command) {
    const terminalOutput = document.getElementById('terminalOutput');
    if (command === 'compile') {
        if (files[filename]) {
            // Simulate compilation
           // compile();
           alert(files[filename])
            terminalOutput.innerHTML += '> Compilation successful\n';
        } else {
            terminalOutput.innerHTML += '> Compilation error: File not found\n';
        }
    } else if (command === 'run') {
        if (files[filename]) {
            // Simulate running
            terminalOutput.innerHTML += '> Running program...\n';
            terminalOutput.innerHTML += `> ${files[filename]}\n`;
        } else {
            terminalOutput.innerHTML += '> Error: File not found\n';
        }
    } else if (command === 'delete') {
        if (files[filename]) {
            delete files[filename];
            terminalOutput.innerHTML += '> File deleted\n';
            updateFileList();
        } else {
            terminalOutput.innerHTML += '> Error: File not found\n';
        }
    } else {
        terminalOutput.innerHTML += '> Unknown file command  ${args[1]}\n';
    }
}

document.getElementById('terminalInput').addEventListener('keypress', function (event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        const command = this.value;
        executeCommand(command);
        this.value = '';
    }
});

function compile() {
            var inp = editor.getValue(); // Get value from CodeMirror

            // Timing the compile process
            const start = performance.now();

            // Simulate the creation of a new Zap instance
            const zapInstance = new Zap(inp);

        // Extract logs from the globalLog to display
        const logs = globalLog.values.map(entry => {
            if (entry.log) return entry.log;
            if (entry.error) return `Error: ${entry.error.message} at line ${entry.error.line}`;
            return '';
        }).join('<br>');
const terminalOutput = document.getElementById('terminalOutput');
        // Update the HTML to display the logs
        terminalOutput.innerHTML = logs;
            // Timing end
            const end = performance.now();
            const timeTaken = end - start;

            // Update the HTML to display the logs and timing
            terminalOutput.innerHTML = `
            kiswahiliScript with .kiss
            ========  ====== ====== =====
            
            <div>Time taken: ${timeTaken.toFixed(2)} ms</div>
            ~~~ compilation results ~~~~~~
            
            <div>${logs}</div>
            ====>time start:${start}
            ====>time end:${end}
            
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            developed by Silivestir Assey ,Isack Wagunda
            Under splannes team ©splannes 2024
            maintained by Silivestir Assey 
            -------     ----------   ----------
            see docs at kiswahiliScript page
            report bugs,disclaimer,privacy,
            
            `;
        }
    </script>
</body>
</html>
