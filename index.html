

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="keywords" content="kiswahiliScript, programming language, Swahili programming, donut, 3D graphics, visualization">
    <meta name="author" content="Silivestir Assey, Isack Wagunda">
    <meta name="date" content="April 2023">
    <title>kiswahiliScript Documentation</title>
    <style>
        #documentationSwahili { display: none; }
        #toggleButton { margin: 10px; }
    </style>
</head>
<body>
    <button id="toggleButton">Switch to Swahili</button>

    <!-- English Documentation -->
    <div id="documentation">
        <h1>kiswahiliScript Documentation</h1>
        <p><strong>Language:</strong> kiswahiliScript</p>
        <p><strong>Version:</strong> Crafted in April 2023</p>
        <p><strong>Authors:</strong> Silivestir Assey, Isack Wagunda</p>
        <p><strong>Contact:</strong></p>
        <ul>
            <li>Silivestir Assey: silivestirassey@gmx.com</li>
            <li>Isack Wagunda: mwlwaphysicsict@gmail.com</li>
        </ul>
        <p><strong>Contributions:</strong> Open for contributions</p>
        
        <h2>Language Constructs</h2>
        <h3>Function</h3>
        <p>Functions in kiswahiliScript are defined using the <code>kazi</code> keyword. Functions encapsulate a block of code that performs a specific task and can be called from other parts of the code.</p>
        <pre><code>kazi FunctionName() {
    // Function body
}</code></pre>
        <p>Example:</p>
        <pre><code>kazi Salamu() {
    elementi("id,output").kontentiNdani("Habari!");
}</code></pre>

        <h3>Array</h3>
        <p>Arrays in kiswahiliScript are declared using the <code>Data</code> type and are used to store multiple values in a single variable.</p>
        <pre><code>Data arrayName []</code></pre>
        <p>Example:</p>
        <pre><code>Data numbers []
numbers = [1, 2, 3, 4, 5]</code></pre>

        <h3>Object</h3>
        <p>Objects are used to group related data and functions together. In kiswahiliScript, objects can be created and manipulated using specific syntax.</p>
        <pre><code>Data myObject = {
    key1: value1,
    key2: value2
}</code></pre>
        <p>Example:</p>
        <pre><code>Data person = {
    jina: "Ali",
    umri: 30
}</code></pre>

        <h3>Variable</h3>
        <p>Variables in kiswahiliScript are used to store data. They are declared with a type or inferred from the assigned value.</p>
        <pre><code>namba variableName = value</code></pre>
        <p>Example:</p>
        <pre><code>namba age = 25</code></pre>

        <h3>Math Operations</h3>
        <p>kiswahiliScript supports standard arithmetic operations such as addition, subtraction, multiplication, and division.</p>
        <pre><code>namba result = 5 + 3 // Addition
result = 10 - 2 // Subtraction
result = 4 * 2 // Multiplication
result = 8 / 2 // Division</code></pre>

        <h3>Cosine and Sine (cos, sin)</h3>
        <p>The <code>cos</code> and <code>sin</code> functions are used to compute the cosine and sine of an angle in radians, respectively.</p>
        <pre><code>namba angle = 1.57 // Radians
namba cosineValue = cos(angle)
namba sineValue = sin(angle)</code></pre>

        <h3>DOM Manipulation</h3>
        <p>kiswahiliScript can manipulate the Document Object Model (DOM) to interact with and update the content of web pages.</p>
        <pre><code>elementi("id,elementID").kontentiNdani(value)</code></pre>
        <p>Example:</p>
        <pre><code>elementi("id,outputContainer").kontentiNdani("Hello World!")</code></pre>

        <h2>Creating a Donut Visualization</h2>
        <p>kiswahiliScript can be used to create a fascinating donut-like visual effect, similar to the famous donut example by Andy Sloane (2006). This visual effect represents a 3D rotating donut rendered in a 2D text-based display. Here's a brief overview of how it works:</p>
        
        <h3>Concept</h3>
        <p>The donut is visualized using mathematical computations to simulate the appearance of a rotating 3D shape. It involves calculations of angles and coordinates to render the donut on a 2D canvas. This is achieved by calculating the positions and shading of the donut’s surface based on trigonometric functions.</p>

        <h3>Core Components</h3>
        <ul>
            <li><strong>Angles and Rotation:</strong> The donut’s rotation is simulated by incrementing angles (theta and phi) in a loop. This creates the illusion of movement.</li>
            <li><strong>Trigonometric Functions:</strong> Functions like <code>cos</code> and <code>sin</code> are used to compute the position of the donut’s surface points.</li>
            <li><strong>Buffer and Drawing:</strong> A buffer is used to store and update the visual representation of the donut. Characters are used to render the donut's appearance based on depth and light intensity.</li>
            <li><strong>Rendering:</strong> The final visual is created by combining characters based on the computed positions and colors, and then displayed on the screen.</li>
        </ul>

        <h3>Example Overview</h3>
        <p>In the provided kiswahiliScript example, the donut is created using the following steps:</p>
        <ol>
            <li>Initialize variables and buffers for storing the donut's state and appearance.</li>
            <li>Define a function to calculate and update the donut’s frame based on angle increments.</li>
            <li>Use nested loops to compute the positions of points on the donut’s surface using trigonometric functions.</li>
            <li>Update the display based on the computed positions, creating the visual effect of a rotating donut.</li>
        </ol>
    </div>

    <!-- Swahili Documentation -->
    <div id="documentationSwahili">
        <h1>Hati ya kiswahiliScript</h1>
        <p><strong>Lugha:</strong> kiswahiliScript</p>
        <p><strong>Toleo:</strong> Ilitengenezwa mnamo Aprili 2023</p>
        <p><strong>Waandishi:</strong> Silivestir Assey, Isack Wagunda</p>
        <p><strong>Mawasiliano:</strong></p>
        <ul>
            <li>Silivestir Assey: silivestirassey@gmx.com</li>
            <li>Isack Wagunda: mwlwaphysicsict@gmail.com</li>
        </ul>
        <p><strong>Michango:</strong> Fungua kwa michango</p>
        
        <h2>Miundo ya Lugha</h2>
        <h3>Kazi</h3>
        <p>Kazi katika kiswahiliScript hutangazwa kwa kutumia neno <code>kazi</code>. Kazi inajumuisha block ya kanuni inayotekeleza kazi maalum na inaweza kupigiwa simu kutoka sehemu nyingine za kanuni.</p>
        <pre><code>kazi JinaLaKazi() {
    // Mwili wa kazi
}</code></pre>
        <p>Mfano:</p>
        <pre><code>kazi Salamu() {
    elementi("id,output").kontentiNdani("Habari!");
}</code></pre>

        <h3>Array</h3>
        <p>Arrays katika kiswahiliScript hutangazwa kwa kutumia aina ya <code>Data</code> na hutumika kuhifadhi thamani nyingi kwenye variable moja.</p>
        <pre><code>Data jinaArray []</code></pre>
        <p>Mfano:</p>
        <pre><code>Data nambari []
nambari.weka(1, 2, 3, 4, 5)</code></pre>

        
                <h3>Object</h3>
        <p>Objects hutumika kuunganisha data na kazi zinazohusiana pamoja. Katika kiswahiliScript, objects zinaweza kuundwa na kusimamiwa kwa kutumia syntax maalum.</p>
        <pre><code>Data objectYangu = {
    ufunguo1: thamani1,
    ufunguo2: thamani2
}</code></pre>
        <p>Mfano:</p>
        <pre><code>Data mtu = {
    jina: "Ali",
    umri: 30
}</code></pre>

        <h3>Variable</h3>
        <p>Variables katika kiswahiliScript hutumika kuhifadhi data. Zinatangazwa kwa aina au zinasalimishwa kutoka kwa thamani iliyopewa.</p>
        <pre><code>namba jinaVariable = thamani</code></pre>
        <p>Mfano:</p>
        <pre><code>namba umri = 25</code></pre>

        <h3>Math Operations</h3>
        <p>kiswahiliScript inaunga mkono operesheni za hesabu kama vile kuongeza, kupunguza, kuzidisha, na kugawanya.</p>
        <pre><code>namba matokeo = 5 + 3 // Kuongeza
matokeo = 10 - 2 // Kupunguza
matokeo = 4 * 2 // Kuzidisha
matokeo = 8 / 2 // Kugawanya</code></pre>

        <h3>Cosine na Sine (cos, sin)</h3>
        <p>Mbinu <code>cos</code> na <code>sin</code> hutumika kuhesabu cosine na sine ya angle kwa radians, mtawalia.</p>
        <pre><code>namba angle = 1.57 // Radians
namba cosineThamani = cos(angle)
namba sineThamani = sin(angle)</code></pre>

        <h3>DOM Manipulation</h3>
        <p>kiswahiliScript inaweza kudhibiti Document Object Model (DOM) ili kuingiliana na kubadilisha maudhui ya kurasa za wavuti.</p>
        <pre><code>elementi("id,elementID").kontentiNdani(thamani)</code></pre>
        <p>Mfano:</p>
        <pre><code>elementi("id,outputContainer").kontentiNdani("Hello World!")</code></pre>

        <h2>Kuunda Onyesho la Donati</h2>
        <p>kiswahiliScript inaweza kutumika kuunda athari ya kuvutia ya donati, inayofanana na mfano maarufu wa donati kutoka kwa Andy Sloane (2006). Athari hii ya kuona inawakilisha umbo la donati la 3D linalozunguka, lililowasilishwa kwenye skrini ya 2D kwa kutumia maandiko. Hapa kuna muhtasari wa jinsi inavyofanya kazi:</p>
        
        <h3>Concept</h3>
        <p>Donati inavyoonekana kwa kutumia hesabu za kijiometri ili kuonyesha muonekano wa umbo la 3D lililojaa. Inahusisha mahesabu ya pembe na kuratibu ili kuonyesha donati kwenye jukwaa la 2D. Hii inafikiwa kwa kuhesabu nafasi na kivuli cha uso wa donati kulingana na shughuli za trigonometri.</p>

        <h3>Sehemu Muhimu</h3>
        <ul>
            <li><strong>Pembe na Mzunguko:</strong> Mzunguko wa donati unavyoonyeshwa kwa kuongeza pembe (theta na phi) kwenye mzunguko. Hii huunda mwonekano wa mwendo.</li>
            <li><strong>Shughuli za Trigonometri:</strong> Mbinu kama <code>cos</code> na <code>sin</code> hutumika kuhesabu nafasi za sehemu za uso wa donati.</li>
            <li><strong>Buffer na Uchoraji:</strong> Buffer hutumika kuhifadhi na kuboresha mwonekano wa donati. Mipangilio hutumika kuchora muonekano wa donati kulingana na kina na mwangaza.</li>
            <li><strong>Uwasilishaji:</strong> Mwonekano wa mwisho huundwa kwa kuchanganya wahusika kulingana na nafasi na rangi zilizohesabiwa, na kisha kuonyeshwa kwenye skrini.</li>
        </ul>

        <h3>Muonekano wa Mfano</h3>
        <p>Katika mfano wa kiswahiliScript uliopewa, donati inaundwa kwa hatua zifuatazo:</p>
        <ol>
            <li>Anzisha variables na buffers kwa ajili ya kuhifadhi hali na muonekano wa donati.</li>
            <li>Tambua kazi ya kuhesabu na kuboresha fremu ya donati kulingana na ongezeko la pembe.</li>
            <li>Tumia miduara ya kurudi kuhesabu nafasi za alama kwenye uso wa donati kwa kutumia shughuli za trigonometri.</li>
            <li>Boreshia onyesho kulingana na nafasi zilizohesabiwa, na kuunda athari ya donati inayozunguka.</li>
        </ol>
    </div>

    <script>
        document.getElementById('toggleButton').addEventListener('click', function() {
            var englishDoc = document.getElementById('documentation');
            var swahiliDoc = document.getElementById('documentationSwahili');
            if (englishDoc.style.display === 'none') {
                englishDoc.style.display = 'block';
                swahiliDoc.style.display = 'none';
                this.textContent = 'Switch to Swahili';
            } else {
                englishDoc.style.display = 'none';
                swahiliDoc.style.display = 'block';
                this.textContent = 'Switch to English';
            }
        });
    </script>
</body>
</html>





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kiswahiliScript</title>

    <!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

    <!-- FontAwesome for icons from CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <!-- CodeMirror CSS from CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">

    <!-- CodeMirror JS from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>

    <!-- jQuery from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

    <!-- CodeMirror Show-Hint CSS from CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
</head>
    <style>
    pre{
      color: white;
    }
    body{
      color:green;
      background-color:#282d36;
    }
        .CodeMirror {
            border: 1px solid #ddd;
            height: auto;
        }
        .hidden {
            display: none;
        }
        .file-list {
            display: flex;
            overflow-x: auto;
            padding: 10px 0;
        }
        .file-list-item {
            cursor: pointer;
            padding: 10px;
            margin-right: 10px;
            border-radius: 4px;
            text-align: center;
            transition: background-color 0.3s, color 0.3s;
        }
        .file-list-item:hover {
            background-color: #f1f1f1;
        }
        .file-list-item.active {
            background-color: #007bff;
            color: white;
            border-bottom: 3px solid #0056b3;
        }
        .navbar {
            margin-bottom: 20px;
        }
        .file-list-item i {
            font-size: 24px;
        }
        #outputContainer {
           
            
            
           
          
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            outline: 0;
        }
        .modal-dialog {
            position: relative;
            width: auto;
            margin: 10px;
        }
        .modal-content {
            position: relative;
            background-color: #fff;
            border: 1px solid #999;
            border-radius: .3rem;
            outline: 0;
            box-shadow: 0 3px 9px rgba(0,0,0,.5);
        }
        .modal-header {
            padding: .75rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }
        .modal-body {
            position: relative;
            padding: 1.25rem;
        }
        .modal-footer {
            padding: .75rem 1.25rem;
            border-top: 1px solid #e9ecef;
            text-align: right;
        }
        .modal-open .modal {
            display: block;
        }
    </style>
</head>
<body>
  <div>kiswahiliScript compailer initialized with donut codes</div>
    <div class="container mt-4">
        <div class="navbar navbar-expand-lg navbar-light bg-light">
            <button class="btn btn-primary mr-2" onclick="openModal()">
                <i class="fas fa-plus"></i> Create File
            </button>
            <button class="btn btn-warning mr-2" onclick="toggleTerminal()">
    <i class="fas fa-terminal"></i> Terminal
</button>
            
            
            <button class="btn btn-secondary mr-2" onclick="toggleEditor()">
                <i class="fas fa-toggle-on"></i> Output
            </button>
            
            
            
            <button class="btn btn-success" onclick="saveFile()">
                <i class="fas fa-save"></i> Save File
            </button>
        </div>

        <!-- File List -->
        <div id="fileList" class="file-list mt-2"></div>

        <!-- Editor Container -->
        <div id="editorContainer" class="mt-2">
            <textarea id="code"></textarea>
        </div>


<!-- Terminal Container -->
<div id="terminalContainer" class="mt-2 hidden">
    <div id="terminalOutput" class="border p-3" style="background: #000; color: #fff; font-family: monospace; height: 300px; overflow-y: auto;"></div>
    <textarea id="terminalInput" class="form-control mt-2" rows="3" placeholder="Type your command here..."></textarea>
</div>



        <!-- Output Container -->
        
        <div id="outputContainer" class="mt-2 hidden">
            <div id="s"></div>
        </div>

        <!-- File Modal -->
        <div class="modal" id="fileModal">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Create New File</h5>
                        <button type="button" class="close" onclick="closeModal()">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <form id="fileForm">
                            <div class="form-group">
                                <label for="fileName">File Name (must end with .kiss)</label>
                                <input type="text" class="form-control" id="fileName" required>
                            </div>
                            <button type="submit" class="btn btn-primary">Create File</button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <script>
        // Initialize CodeMirror editor
        var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
            mode: "javascript",
            theme: "dracula",
            lineNumbers: true,
            matchBrackets: true,
            autoCloseBrackets: true,
            extraKeys: {
                "Ctrl-Space": "autocomplete"
            }
        });
        
        
        editor.setValue(`kazi TengenezaDonatiLinaloZunguka() {
      
     
     sentensi timer=""
      timer = null;
     namba theta_sp = 0
     namba phi_sp = 0
     Data b []
     Data zBuffer []
     
     
     
     
     kazi ChoraFremuZaDonati() {
     theta_sp =theta_sp+0.07;
     phi_sp =phi_sp+ 0.03;
     
     cosTheta_sp = cos(theta_sp)
     sinTheta_sp = sin(theta_sp)
     cosPhi_sp = cos(phi_sp)
     sinPhi_sp = sin(phi_sp)
     
 
   ikiwa(namba k = 0; k < 1760; k++) {
     b[k] = k % 80 == 79 ? "\\n" : "..";
    
     }
     
     
     
      ikiwa (namba k = 0; k < 1760; k++) {
     
     zBuffer[k] = 0;
     }
     
     ikiwa (namba theta = 0; theta < 6.28; theta += 0.07) {
      cosTheta = cos(theta)
      sinTheta = sin(theta)
 
     ikiwa (namba phi = 0; phi < 6.28; phi += 0.02) {
      sinPhi = sin(phi)
      cosPhi = cos(phi)
      circleX = cosTheta + 2;
     z =
     sinPhi * circleX * sinTheta_sp + sinTheta * cosTheta_sp + 5;
      D = 1 / z;
      t =
     sinPhi * circleX * cosTheta_sp - sinTheta * sinTheta_sp;
      x=
    0.01 |(40 +
     30 *
     D *
     (cosPhi * circleX * cosPhi_sp - t * sinPhi_sp));
     
     
      y=
     0 |
     (12 +
     15 *
     D *
     (cosPhi * circleX * sinPhi_sp + t * cosPhi_sp));
     
     
     
     o = x + 80 * y;
     
     
     
     
     
      N =
     0 |
     (8 *
     ((sinTheta * sinTheta_sp -
     sinPhi * cosTheta * cosTheta_sp) *
     cosPhi_sp -
     sinPhi * cosTheta * sinTheta_sp -
     sinTheta * cosTheta_sp -
     cosPhi * cosTheta * sinPhi_sp));
     
     kama (
     y < 22 &&
     y >= 0 &&
     x >= 0 &&
     x < 79 &&
     D > zBuffer[o]
     ) {
     zBuffer[o] = D;
          b[o]="00000000011111111111111"[N>0?N:0];
     }
     
     }
     
     }
     
     
     
     
      aa=b.join("");
      
     elementi("id,outputContainer").kontentiNdani(aa)
     }
     kazi FanyaDonatiLizunguke() {
     kama(timer === null) {
     namba a=50
     timer = setInterval(ChoraFremuZaDonati, a)
     } (){
     
timer= clearInterval(timer)
}
    }
     
   FanyaDonatiLizunguke()
     
     
     
    }
     
   TengenezaDonatiLinaloZunguka()
     
     
     `)

        // File management
        var files = {};
        var currentFileName = null;

        function createFile(name) {
            if (!name.endsWith('.kiss')) {
                alert('File must end with .kiss');
                return;
            }
            if (files[name]) {
                alert('File already exists');
                return;
            }
            files[name] = '';
            currentFileName = name; // Set current file to newly created one
            updateFileList();
            closeModal();
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            Object.keys(files).forEach(fileName => {
                const div = document.createElement('div');
                div.className = 'file-list-item' + (fileName === currentFileName ? ' active' : '');
                div.innerHTML = `<i class="fas fa-file-code"></i><br>${fileName}`;
                div.onclick = () => loadFile(fileName);
                fileList.appendChild(div);
            });
        }

        function loadFile(name) {
            currentFileName = name;
            editor.setValue(files[name]);
            document.getElementById('editorContainer').classList.remove('hidden');
            document.getElementById('outputContainer').classList.add('hidden');
            updateFileList(); // Update the file list to reflect the selected file
        }

        function saveFile() {
            if (currentFileName) {
                files[currentFileName] = editor.getValue();
                alert('File saved!');
            } else {
                alert('No file selected to save.');
            }
        }

        function toggleEditor() {
            var editorContainer = document.getElementById('editorContainer');
            var outputContainer = document.getElementById('outputContainer');

            if (editorContainer.classList.contains('hidden')) {
                editorContainer.classList.remove('hidden');
                outputContainer.classList.add('hidden');
            } else {
                editorContainer.classList.add('hidden');
               
                editorContainer.classList.add('hidden');
                outputContainer.classList.remove('hidden');
                Compile();
            }
        }








class Environment {
  constructor(enclosing) {
    this.errorHandler = new ErrorHandler();
    this.values = {};
    this.enclosing = null;
    if (enclosing) {
      this.enclosing = enclosing;
    };
  };

  define(identifier, value) {
    this.values[identifier] = value;
  };

  assign(identifier, value) {
    if (!Object.keys(this.values).includes(identifier))
    {
      if (this.enclosing) 
      {
        return this.enclosing.assign(identifier, value);
      } 
      else 
      {
        this.errorHandler.throw(
          `UNDEFINED VARIABLE ${identifier}`
        );
      }
    } 
    else 
    {
      this.values[identifier] = value;
    };
  };

  get(identifier) {
    if (Object.keys(this.values).includes(identifier)) 
    {
      return this.values[identifier];
    }
    else 
    {
      if (this.enclosing) 
      {
        return this.enclosing.get(identifier);
      };
      this.errorHandler.throw(
        `UNDEFINED VARIABLE ${identifier}`
      );
    };
  };
};








class ErrorHandler {
  constructor() {
    this.log = globalLog;
  };

  throw(msg, line, col) {
    let err;
    if (line && col) {
      err = `\n\n${msg} -- ln: ${line}, col: ${col}\n`
    } else {
      err = `\n\n${msg}\n`
    };
    try {
      throw new Error(err);
    } catch (e) {
      console.error(e);
      this.log.error(e, line);
      // process.exit(1);
    };
  };
};



class Assignment {
  constructor(token, expression, evaluator, environment) {
    this.identifier = token.value;
    this.expression = expression;

    this.evaluator = evaluator;
    this.environment = environment;
    this.evaluator.load(expression);
    this.value = this.evaluator.evaluate().value;
    this.operate();
  };
  operate() {
    this.environment.assign(this.identifier, this.value);
  };
};

class Binary {
  constructor(leftNode, operator, rightNode, evaluator) {
    this.evaluator = evaluator;

    this.evaluator.load(leftNode);
    this.leftNode = this.evaluator.evaluate();

    this.evaluator.load(rightNode);
    this.rightNode = this.evaluator.evaluate();
    
    this.operator = operator.type;
    this.value = this.operate();
  };

  operate() {
    if (this.operator == 'PLUS') {
      return this.leftNode.value + this.rightNode.value;
    };
    if (this.operator == 'MINUS') {
      return this.leftNode.value - this.rightNode.value;
    };
    if (this.operator == 'MULTIPLY') {
      return this.leftNode.value * this.rightNode.value;
    };
    if (this.operator == 'DIVIDE') {
      return this.leftNode.value / this.rightNode.value;
    };
    if (this.operator == 'MODULO') {
      return this.leftNode.value % this.rightNode.value;
    };
    if (this.operator == 'EQUALTO') {
      return this.leftNode.value == this.rightNode.value;
    };
    if (this.operator == 'NOTEQUALTO') {
      return this.leftNode.value != this.rightNode.value;
    };
    if (this.operator == 'GREATERTHAN') {
      return this.leftNode.value > this.rightNode.value;
    };
    if (this.operator == 'LESSTHAN') {
      return this.leftNode.value < this.rightNode.value;
    };
    if (this.operator == 'GREATERTHANEQUAL') {
      return this.leftNode.value >= this.rightNode.value;
    };
    if (this.operator == 'LESSTHANEQUAL') {
      return this.leftNode.value <= this.rightNode.value;
    };
  }
};

class Unary {
  constructor(operator , expression, evaluator) {
    this.evaluator = evaluator;
    this.evaluator.load(expression);

    this.operator = operator;
    this.expression = expression;
    this.value = this.operate();
  }
  operate() {
    if (this.operator.type == "MINUS") {  
      return ( - ( this.evaluator.evaluate().value ) );
    };
    if (this.operator.type == "PLUS") {
      return (this.evaluator.evaluate().value);
    }
    if (this.operator.type == "NOT") {
      return !(this.evaluator.evaluate().value);
    }
  };
}

class Call {
  constructor(callee, args, evaluator, environment) {
    this.errorHandler = new ErrorHandler();
    this.callee = callee;
    this.evaluator = evaluator;
    this.args = this.evaluateArgs(args);
    this.environment = environment;
    this.value = this.operate();
  };

  evaluateArgs(args) {
    let parsedArgs = [];
    for (let arg of args) {
      this.evaluator.load(arg);
      let argValue = this.evaluator.evaluate().value;
      parsedArgs.push(argValue);
    }
    return parsedArgs;
  };

  operate() {
    const zapFunction = this.environment.get(this.callee.value);
    if (!(zapFunction instanceof ZapFunction)) {
      this.errorHandler.throw(
        `INVALID CALLEE TYPE`,
        this.callee.line,
        this.callee.col,
      );
    };
    return zapFunction.call(this.args);
  };
};

class Literal {
  constructor(token) {
    if (token.type == "NUMBER") {
      this.value = parseFloat(token.value);
    };
    if (token.type == "STRING") {
      this.value = token.value;
    };
  };
};

class Group {
  constructor(expression, evaluator) {
    this.evaluator = evaluator;
    this.evaluator.load(expression);
    this.value = this.evaluator.evaluate().value;
  };
};

class Variable {
  constructor(token, environment) {
    this.identifier = token.value;
    this.environment = environment;
    this.value = this.fetchValue();
  }
  fetchValue() {
    return this.environment.get(this.identifier);
  };
}

/*
                 ::::{[{[ --> THE EVALUATING LOGIC <-- ]}]}::::

        The logic behind the evaluator is to create a tree of operations.
      It starts by iterating through the Whole raw expression (token list),
                            from right to left,
              trying to find the operators of lowest precedence 
                    (the ones that will be executed last).
              As soon as it finds an operator of type "+" or "-",
                 it becomes the first expression in the tree.
       The expressions can be of 4 types: Binary, Unary, Group or Literal.

             The Evaluator will iterate through the raw Expression,
                  Always trying break down bigger expressions
             into smaller ones until it works with only Primaries.

                             THE EXPRESSION TYPES

          Binary Expressions :
            --> Have a left and right sub-expression, along with an operator.
            --> The expression's value is calculated by
                joining the values of the left and right 
                sub-expressions through the operator.
            --> EXAMPLES:
      
          1.     "PLUS"                    2.        "MULTPLY"                                            
                   /\                                    /\                            
                  /  \                                  /  \                           
                 5    6                               5+6  7-3                    
                                                                                  
           Calculated Value: 11                  Calculated Value: 44                                                                 
                         
            --> {{ RECURSION ALERT }}
                Notice how in Example 2,
                the sub-expressions are also of type "Binary Expression"   



          Unary Expressions :
            --> Have a sub-expression, along with a unary operator ("!" or "-").
            --> The expression's value is calculated by
                joining the value of the sub-expression with the operator.
            --> EXAMPLES:
      
          1.     "PLUS"                    2.        "MINUS"                                            
                    |                                   |                           
                    5                                   9                     
                                                                
                                                                                  
           Calculated Value: 5                  Calculated Value: -9                                                                 
                          


          Group Expressions :
            --> Are the ones in between parenthesis.
            --> The expression's value is calculated by parsing
                the expression in between parenthesis.
            --> Examples:
          
          1.    "(2 + 3)"                                                             
                    |
                    V                                                         
                   2+3    
                    |
                    V
                  "PLUS"                                           
                    /\                                            
                   /  \
                  2    3
                   
           Calculated Value: 5                   
                
                     
           
          Primary Expressions :
            --> Are the ones that represent a Literal (String, Int, Float, etc.).
            --> The expression's value is the Literal it holds.
            --> Examples:
          
          1.      "245"                                                             
                    
           Calculated Value: 245                              


                            {[{[ --> EXAMPLE <--]}]}
                                                                                                                                                                                  
                    (3 + 5) - 8 * (4 - (8 / 2) - 7) + 4 * (9)                                                                                                                                                    
                                                    |                                                                                                                              
                                                  "PLUS"                                                                                                                                           
                                                    /\                                                                                                                                         
                                                   /  \                                                                                                                                        
                     (3 + 5) - 8 * (4 - (8 / 2) - 7)   4 * (9)                                                                                                                                                                 
                             |                           |                                    
                          "MINUS"                      "MULT"                                                                                                                                  
                            /\                           /\                                                                                                                                                                                       
                           /  \                         4   (9)                                                                                                                                                       
                          /    \                             |                                                                    
                  (3 + 5)      8 * (4 - (8 / 2) - 7)         9                                                                                       
                /                |                                                                                                          
          GROUP(3+5)         "MULTIPLY"                                                                                                      
              |                  /\                                                                                         
            3 + 5               /  \                                                                     
              |                8    (4 - (8 / 2) - 7)                                                         
            "PLUS"                          |                             
              /\                     4 - (8 / 2) - 7                                                     
             /  \                                |                                         
            3    5                            "MINUS"                                 
                                                 /\                             
                                                /  \                              
                                    4 - (8 / 2)      7                         
                                      |                                        
                                   "MINUS"                                          
                                      /\                                                                        
                                     /  \                                                                                                        
                                    4    (8 / 2)                                                                    
                                            |                                                                
                                          8 / 2                                                                  
                                            |                                                                
                                         "DIVIDE"                                                                   
                                            /\                                                                
                                           /  \        
                                          8    2
                                           

*/

class Evaluator {
  constructor(environment) {
    this.environment = environment;

    this.errorHandler = new ErrorHandler();
    this.rawExpression = null;
    this.index = null;
    this.previousToken = null;
    this.currentToken = null;
    this.nextToken = null;
    this.openingParen = 0;
    this.closingParen = 0;
    this.bars = 0;
  };

  load(tokens) {
    this.rawExpression = tokens;
    this.resetToEnd();
  }

  reset() {
    this.index = 0;
    this.previousToken = null;
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = this.rawExpression[this.index+1];
    this.openingParen = 0;
    this.closingParen = 0;

    this.checkParenthese();
    this.checkBar();
  };

  resetToEnd() {
    this.index = this.rawExpression.length - 1;
    this.previousToken = this.rawExpression[this.index - 1];
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = null;
    this.openingParen = 0;
    this.closingParen = 0;

    this.checkParenthese();
    this.checkBar();
  };

  next() {
    this.index++;
    this.previousToken = this.rawExpression[this.index-1];
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = this.rawExpression[this.index+1];
    
    this.checkParenthese();
    this.checkBar();
  };

  prev() {
    this.index--;
    this.previousToken = this.rawExpression[this.index-1];
    this.currentToken = this.rawExpression[this.index];
    this.nextToken = this.rawExpression[this.index+1];
    
    this.checkParenthese();
    this.checkBar();
  };

  checkParenthese() {
    if (this.currentToken) {
      if (this.currentToken.type == "LPAREN") {
        this.openingParen++;
      };
      if (this.currentToken.type == "RPAREN") {
        this.closingParen++;
      };
    };
  };

  checkBar() {
    if (this.currentToken) {
      if (this.currentToken.type == "BAR") {
        this.bars++;
      };
    };
  };

  isInGroup() {
    return (this.openingParen != this.closingParen) || (this.bars % 2 != 0);
  }

  isOperator(token) {
    let operators = [
      "MULTIPLY", 
      "DIVIDE", 
      "PLUS", 
      "MINUS", 
      "MODULO", 
      "GREATERTHAN", 
      "GREATERTHANEQUAL",
      "LESSTHAN",
      "LESSTHANEQUAL", 
      "EQUALTO",
      "NOTEQUALTO",
      "NOT",
    ];
    return (operators.includes(token.type) );
  };

  isEqualityOperator(token) {
    let operators = [
      "EQUALTO",
      "NOTEQUALTO",
    ];
    return (operators.includes(token.type) );
  }

  isComparissonOperator(token) {
    let operators = [ 
      "GREATERTHAN", 
      "GREATERTHANEQUAL",
      "LESSTHAN",
      "LESSTHANEQUAL", 
    ];
    return (operators.includes(token.type) );
  }

  isAdditionOperator(token) {
    let operators = [
      "PLUS",
      "MINUS",
    ];
    return (operators.includes(token.type) );
  }

  isMultiplicationOperator(token) {
    let operators = [
      "MULTIPLY",
      "DIVIDE",
      "MODULO",
    ];
    return (operators.includes(token.type) );
  }

  isUnaryOperator(token) {
    let operators = [
      "MINUS",
      "NOT",
      "PLUS",
    ];
    return (operators.includes(token.type) );
  }

  isLiteral(token) {
    let types = [
      "STRING",
      "NUMBER",
    ];
    return (types.includes(token.type) );
  }

  isReserved(token) {
    let types = [ 
      "FOR", 
      "WHILE",
      "RETURN",
      "SHOW", 
    ];
    return types.includes(token.type);
  };

  isForbidden(token) {
    let types = [ 
      "RBRACE",
      "LBRACE",
      "SEMICOLON", 
      "DOT",
      "DECLARATOR",
    ];
    return types.includes(token.type);
  }

  handleAssignment() {
    // console.log('isAssignment')
    let assigned = this.rawExpression.slice(0, this.index);
    let expression = this.rawExpression.slice(this.index+1);

    if (assigned.length != 1 || !expression.length) {
      this.errorHandler.throw(
        'UNABLE TO PARSE ASSIGNMENT',
        this.currentToken.line,
        this.currentToken.col
      );
    };

    let identifier = assigned[0];

    if (identifier.type != 'IDENTIFIER') {
      this.errorHandler.throw(
        'INVALID ASSIGNEE',
        this.currentToken.line,
        this.currentToken.col
      );
    };

    let node = new Assignment(
      identifier,
      expression,
      this,
      this.environment
    );
    return node;
  };

  handleBinary() {
    // console.log('isBinary')
    let leftNode = this.rawExpression.slice(0, this.index);
    let rightNode = this.rawExpression.slice(this.index+1);

    if (!leftNode.length || !rightNode.length) {
      this.errorHandler.throw(
        'UNABLE TO PARSE BINARY EXPRESSION',
        this.currentToken.line,
        this.currentToken.col
      );
    };

    let node = new Binary(
      leftNode,
      this.currentToken,
      rightNode,
      this
    )
    return node;
  }

  handleUnary() {
    // console.log('isUnary')
    let expr = this.rawExpression.slice(this.index+1);

    if (!expr.length) {
      this.errorHandler.throw(
        'UNABLE TO PARSE UNARY EXPRESSION',
        this.currentToken.line,
        this.currentToken.col
      );
    }

    let node = new Unary(
      this.currentToken,
      expr,
      this,
    );
    return node;
  };

  handleCall() {
    let callee = this.previousToken;
    let args = [];
    let currentArgument = [];

    this.next();
    if (!this.currentToken) {
      this.errorHandler.throw(
        `UNABLE TO PARSE CALL EXPRESSION`,
        this.previousToken.line,
        this.previousToken.col
      );
    }

    while (this.currentToken.type != 'BAR') {
      if (this.currentToken.type != 'COMMA') {
        currentArgument.push(this.currentToken);
      } else {
        args.push(currentArgument);
        currentArgument = [];
      };
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '|' after argument list`,
          this.previousToken.line,
          this.previousToken.col
        )
      };
    };

    if (currentArgument.length) {
      args.push(currentArgument);
      currentArgument = [];
    }
    
    let node = new Call(
      callee,
      args,
      this,
      this.environment,
    )
    return node;
  };

  handleOpenParen() {
    // console.log('isGroup')
    let group = []
    while (this.isInGroup()) {
      group.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(`EXPECTED ')' AFTER EXPRESSION -- EOF`);
      };
    };
    let node = new Group(
      group,
      this
      );
    return node;
  };

  handlePrimary() {
    // console.log('isPrimary')
    let node = new Literal(this.currentToken);
    return node;
  };

  handleVariable() {
    // console.log('isVariable')
    let node = new Variable(
      this.currentToken, 
      this.environment
    );
    return node;
  };

  handleReserved() {
    this.errorHandler.throw(
      'UNEXPECTED KEYWORD',
      this.currentToken.line,
      this.currentToken.col,
    );
  };

  handleForbidden() {
    this.errorHandler.throw(
      'FORBIDDEN SYMBOL IN EXPRESSION',
      this.currentToken.line,
      this.currentToken.col,
    );
  };

  evaluate() {
    // console.log('expression to parse');
    // console.log(this.rawExpression);

    /*
      Parsing the expressions with lowest precedence (EQUALITY)
      We iterate through the rawExpression from right to left due to the association rule of these operators.

      The order of precedence is as follows
      --> EQUALITY
      --> COMPARISSON
      --> ADDITION - SUBTRACTION
      --> MULTIPLICATION - DIVISION
      --> UNARY
      --> GROUP
      --> PRIMARY
    */


    while (this.currentToken) {
      if (this.isForbidden(this.currentToken)) {
        this.handleForbidden();
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.currentToken) {
      if (this.isReserved(this.currentToken)) {
        this.handleReserved();
      };
      this.prev();
    };
    this.reset();

    while (this.currentToken && this.nextToken) {
      if (this.isLiteral(this.currentToken) && this.isLiteral(this.nextToken)) { 
        this.errorHandler.throw(
          'UNEXPECTED LITERAL',
          this.nextToken.line,
          this.nextToken.col
        );
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == 'EQUALS') {
        if (!this.isInGroup()) {
          return this.handleAssignment();
        };
      };
      this.next();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isEqualityOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleBinary();
        };
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isComparissonOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleBinary();
        };
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isAdditionOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          if (this.previousToken) {
            if (!this.isOperator(this.previousToken)) {
              return this.handleBinary();
            };
          };
        };
      };
      this.prev();
    };
    this.resetToEnd();

    while (this.index >= 0) {
      if (this.isMultiplicationOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleBinary();
        };
      };
      this.prev();
    };
    this.reset();

    while (this.currentToken) {
      if (this.isUnaryOperator(this.currentToken)) {
        if (!this.isInGroup()) {
          return this.handleUnary();
        };
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == 'BAR') {
        return this.handleCall();
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == "LPAREN") {
        this.next();
        return this.handleOpenParen();
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == "NUMBER" || this.currentToken.type == "STRING") {
        return this.handlePrimary();
      };
      this.next();
    };
    this.reset();

    while (this.currentToken) {
      if (this.currentToken.type == "IDENTIFIER") {
        return this.handleVariable();
      };
      this.next();
    };
    this.reset();

    return {
      value : undefined,
    };

  };
};




// const { Environment } = require('../environment/Environment');
// const { Lexer } = require('../lexer/lexer');

// console.time('parsing')
// const env = new Environment();
// const lexer = new Lexer("1");
// const parser = new Parser(env);
// parser.load(lexer.tokens);
// result = parser.parse();
// console.log(result);

// console.timeEnd('parsing')



class Interpreter {
  constructor(input) {
    globalLog.clear();
    
    this.errorHandler = new ErrorHandler();
    this.environment = new Environment(null);
    this.lexer = new Lexer(input);
    this.parser = new Parser(this.environment);
    this.parser.load(this.lexer.tokens);
    this.statements = this.parser.parse();
  };
};




class CharSeperator {
  constructor(input) {
    this.errorHandler = new ErrorHandler();
    this.input = input;
    this.charTypes = [];
    this.getCharTypes();
  };

  getCharTypes() {
    let line = 1;
    let col = 1;
    for (let char of this.input.split('')) {
      for (let [ token , verification ] of Object.entries(tokenList)) {
        if (verification(char)) {
          const charDescription = {};
          charDescription['type'] = token;
          charDescription['line'] = line;
          charDescription['col'] = col;
          charDescription['value'] = char;
          if (charDescription.type == "UNRECOGNIZED") {
            this.errorHandler.throw(`UNRECOGNIZED SYNTAX`, charDescription['line'], charDescription['col']);
          } else {
            this.charTypes.push(charDescription);
          };
          break;
        }
      }
      if (char == '\n') {
        col = 1;
        line++;
      } else {
        col++;
      };
    };
  };
};


/*



                          {[{[ --> THE LEXER <-- ]}]}

                  The goal here is to take a stream of inputs
               & separate it into tokens that have meaning to the
                                   language.

               We start by separating each character of the stream
                                  by its type.
                             The possible types are:

           1. +  2. -  3. *  4. /  5. %  6. =  7. == 8. != 9. >  10.  <

           11.<= 12.<= 13. ! 14. ( 15. ) 16. { 17. } 18. ; 19. ' 20. .

       Besides these types, the char can be a Letter, Number or Whitespace.


              After classifying all the characters, we can move on
          to grouping these symbols into larger lexemes or tokens that
                   our language will be able to understand.



*/


class Lexer {
  constructor (input) {
    this.charSeperator = new CharSeperator(input);
    this.errorHandler = new ErrorHandler();
    this.charTypes = this.charSeperator.charTypes;
    this.index = 0;
    this.char = this.charTypes[this.index];
    this.currentToken = {};
    this.tokens = [];
    this.lex();
  }

  resetCurrentToken() {
    this.currentToken = {};
  }

  next() {
    this.index++;
    this.char = this.charTypes[this.index];
  };

  peakNext() {
    try {
      return this.charTypes[this.index + 1];
    } catch {
      return false;
    };
  };

  handleStr() {
    this.currentToken = {
      "type" : "STRING",
      "line" : this.char.line,
      "col" : this.char.col,
      "value" : "",
    };

    if (this.peakNext()) {
      this.next();
    } else {
      this.errorHandler.throw('EOF WHILE PARSING STRING', this.currentToken.line, this.currentToken.col);
    }

    while (this.char.type != "QUOTE") {
      this.currentToken.value = this.currentToken.value.concat(this.char.value);
      this.next();
      if (!this.char) {
        this.errorHandler.throw('EOF WHILE PARSING STRING', this.currentToken.line, this.currentToken.col);
      };
    };
    this.tokens.push(this.currentToken);
    this.resetCurrentToken();
    this.next();
    this.lex();
  };

  handleNum() {
    let hasDecimal = false;

    this.currentToken = {
      "type" : "NUMBER",
      "line" : this.char.line,
      "col" : this.char.col,
      "value" : "",
    };

    // Long statements to handle decimal and int numbers
    while (this.char.type == "NUMBER" || (!hasDecimal && this.char.type == "DOT" && this.peakNext() && this.peakNext().type == "NUMBER")) {
      if (this.char.type == "DOT") {
        hasDecimal = true;
      };
      this.currentToken.value = this.currentToken.value.concat(this.char.value);
      this.next();
      if (!this.char) {
        break;
      };
    };
    this.tokens.push(this.currentToken);
    this.resetCurrentToken();
    this.lex();
  };

  handleId() {
    this.currentToken = {
      "type" : "IDENTIFIER",
      "line" : this.char.line,
      "col" : this.char.col,
      "value" : "",
    };

    while (this.char.type == "NUMBER" || this.char.type == "LETTER") {
      this.currentToken.value = this.currentToken.value.concat(this.char.value);
      this.next();
      if (!this.char) {
        break;
      };
    };

    if (Object.keys(reserved).includes(this.currentToken.value)) {
      this.currentToken.type = reserved[this.currentToken.value];
    };

    this.tokens.push(this.currentToken);
    this.resetCurrentToken();
    this.lex();
  };


  isDoubleCharOperator() {
    if (this.peakNext()) {
      let operatorToTest = this.char.value.concat(this.peakNext().value)
      for (let [ type , verification ] of Object.entries(tokenList)) {
        if (verification(operatorToTest) && (type != "UNRECOGNIZED")) {
          return {
            "type" : type,
            "line" : this.char.line,
            "col" : this.char.col,
            "value" : operatorToTest,
          };
        };
      };
      return false;
    };
  };

  handleOperator() {
    if (this.char.type != "WHITESPACE") {
      let doubleCharOperator = this.isDoubleCharOperator();
      if (doubleCharOperator) {
        this.next();
        this.currentToken = doubleCharOperator;
        this.tokens.push(this.currentToken);
        this.resetCurrentToken();
      } else {
        this.currentToken = this.char;
        this.tokens.push(this.currentToken);
        this.resetCurrentToken();
      };
    };
    this.next();
    this.lex();
  };

  lex() {
    if (this.char) {
      switch(this.char.type) {
        case "QUOTE":
          this.handleStr();
          break;
        case "NUMBER":
          this.handleNum();
          break;
        case "LETTER":
          this.handleId();
          break;
        default:
          this.handleOperator();
      };
    };
  };
};





const tokenList = {
  "PLUS" : (input) => input == '+',
  "MINUS" : (input) => input == '-',
  "DIVIDE" : (input) => input == '/',
  "MULTIPLY" : (input) => input == '*',
  "MODULO" : (input) => input == '%',

  "EQUALS" : (input) => input == '=',

  "GREATERTHAN" : (input) => input == '>',
  "LESSTHAN" : (input) => input == '<',
  "NOT" : (input) => input == '!',
  "GREATERTHANEQUAL" : (input) => input == '>=',
  "LESSTHANEQUAL" : (input) => input == '<=',
  "NOTEQUALTO" : (input) => input == '!=',
  "EQUALTO" : (input) => input == '==',

  "FATARROW" : (input) => input == '=>',

  "LPAREN" : (input) => input == '[',
  "RPAREN" : (input) => input == ']',
  "LBRACE" : (input) => input == '{',
  "RBRACE" : (input) => input == '}',
  "BAR" : (input) => input == ':',
  "COMMA" : (input) => input == ',',

  "SEMICOLON" : (input) => input ==';',
  "QUOTE" : (input) => input == "'",
  "DOT" : (input) => input =='.',

  "DECLARATOR" : (input) => input == '$',

  "NUMBER" : (input) => /^[0-9]+$/.test(input),
  "LETTER" : (input) => /^[a-zA-Z]+$/.test(input),
  "WHITESPACE" : (input) => !/\S/.test(input),

  "UNRECOGNIZED" : (input) => true,
};

const reserved = {
  "ikiwa" : 'FOR',
  "wakati" : 'WHILE',
  "rudisha" : 'RETURN',
  "andika" : "SHOW",
  "kama" : "IF",
  "au" : "ELSE",
  "kazi" : "FUNCTION",
};







class Log {
  constructor() {
    this.values = [];
  };

  add(log) {
    this.values.push({
      'log': log,
    });
  };

  error(e, ln) {
    this.values.push({
      'error' : {
        'message' : e.message,
        'line' : ln,
      }
    });
  };
  
  clear() {
    this.values = [];
    return this;
  };
};

let globalLog = new Log();


class BlockStmt {
  constructor(statement, environment) {
    this.statement = statement;
    this.body = this.fetchBody();
    this.parser = new Parser(environment);
    this.execute()
  };

  fetchBody() {
    return this.statement.slice(1, -1);
  };

  execute() {
    this.parser.load(this.body);
    this.statements = this.parser.parse();
  };
};

class PrintStmt {
  constructor(statement, evaluator, log) {
    this.log = log;
    this.statement = statement;
    this.expression = this.fetchExpression();
    this.evaluator = evaluator;
    this.value = null;
    this.execute();
  };

  fetchExpression() {
    return this.statement.slice(1);
  };

  execute() {
    this.evaluator.load(this.expression);
    this.value = this.evaluator.evaluate().value;

    if (this.value != undefined) {
      // console.log(this.value);
      this.log.add(this.value);

    } else {
      // console.log();
      this.log.add('');
    };
  };
};

class ExprStmt {
  constructor(statement, evaluator) {
    this.expression = statement;
    this.evaluator = evaluator;
    this.evaluator.load(this.expression);
    this.value = this.evaluator.evaluate().value;
  }
}

class DeclarationStmt {
  constructor(statement, evaluator, environment) {
    this.errorHandler = new ErrorHandler();
    this.statement = statement;
    this.evaluator = evaluator;
    this.environment = environment;

    this.value = null;
    this.identifier = statement[1].value;
    this.execute()
  };

  fetchValue() {
    let value = null;
    if (this.statement[2]) {
      if (this.statement[2].type == 'EQUALS') {
        let expression = this.statement.slice(3);
        this.evaluator.load(expression);
        value = this.evaluator.evaluate().value;
        if (value == undefined) {
          this.errorHandler.throw(
            'INVALID DECLARATION STATEMENT',
            this.statement[0].line,
            this.statement[0].col
          );
        };
      }
      else {
        this.errorHandler.throw(
          'INVALID DECLARATION STATEMENT',
          this.statement[0].line,
          this.statement[0].col
        );
      };
    };
    return value;
  };
    
  
  execute() {
      this.value = this.fetchValue();
      return this.environment.define(this.identifier, this.value);
  };
};

class IfStmt {
  constructor(statement, evaluator, environment) {
    this.evaluator = evaluator;
    this.parser = new Parser(environment);
    this.errorHandler = new ErrorHandler();

    this.statement = statement;

    this.expression = [];
    this.thenBlock = [];
    this.elseBlock = null;

    this.index = 1;
    this.currentToken = this.statement[this.index];
    this.prevToken = null;

    this.openingBrace = 0;
    this.closingBrace = 0;

    this.execute();
  };

  next() {
    this.prevToken = this.statement[this.index];
    this.index++;
    this.currentToken = this.statement[this.index];
    this.checkBrace();
  };

  checkBrace() {
    if (this.currentToken) {
      if (this.currentToken.type == 'LBRACE') {
        this.openingBrace++;
      };
      if (this.currentToken.type == 'RBRACE') {
        this.closingBrace++;
      };
    };
  };

  isInBlock() {
    return this.closingBrace != this.openingBrace;
  };

  splitBlock() {
    while (!this.isInBlock()) {
      this.expression.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '{' AFTER EXPRESSION`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
    };

    while (this.isInBlock()) {
      this.thenBlock.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '}' AFTER THEN BLOCK`,
          this.prevToken.line,
          this.prevToken.col
        );
      }
    };
    this.thenBlock.push(this.currentToken);
    this.thenBlock.push({
      type: 'SEMICOLON', 
      value: ';'
    });
    this.next();

    if (this.currentToken) {
      if (this.currentToken.type == 'ELSE') {
        this.next();
        if (this.isInBlock()) {
          this.elseBlock = [];

          while (this.isInBlock()) {
            this.elseBlock.push(this.currentToken);
            this.next();
            if (!this.currentToken) {
              this.errorHandler.throw(
                `EXPECTED '}' AFTER ELSE BLOCK`,
                this.prevToken.line,
                this.prevToken.col
              );
            };
          };
          this.elseBlock.push(this.currentToken);
          this.elseBlock.push({
            type: 'SEMICOLON', 
            value: ';'
          });
          this.next();
        }
        else {
          this.errorHandler.throw(
            `UNABLE TO PARSE ELSE STATEMENT`,
            this.prevToken.line,
            this.prevToken.col
          );
        };
      }
      else {
        this.errorHandler.throw(
          `UNEXPECTED KEYWORD AFTER IF STATEMENT`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
    };
  };

  execute() {
    this.splitBlock();

    this.evaluator.load(this.expression);
    let approve = this.evaluator.evaluate().value;

    if (approve) {
      this.parser.load(this.thenBlock);
      this.parser.parse();
    };
    if (!approve) {
      if (this.elseBlock) {
        this.parser.load(this.elseBlock);
        this.parser.parse();
      };
    };
  };
};

class WhileStmt {
  constructor(statement, evaluator, environment) {
    this.evaluator = evaluator;
    this.parser = new Parser(environment);
    this.errorHandler = new ErrorHandler();

    this.statement = statement;

    this.expression = [];
    this.body = [];

    this.index = 1;
    this.currentToken = this.statement[this.index];
    this.prevToken = null;

    this.openingBrace = 0;
    this.closingBrace = 0;

    this.execute();
  };

  next() {
    this.prevToken = this.statement[this.index];
    this.index++;
    this.currentToken = this.statement[this.index];
    this.checkBrace();
  };

  checkBrace() {
    if (this.currentToken) {
      if (this.currentToken.type == 'LBRACE') {
        this.openingBrace++;
      };
      if (this.currentToken.type == 'RBRACE') {
        this.closingBrace++;
      };
    };
  };

  isInBlock() {
    return this.closingBrace != this.openingBrace;
  };

  splitBlock() {
    while (!this.isInBlock()) {
      this.expression.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '{' AFTER EXPRESSION`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
    };

    while (this.isInBlock()) {
      this.body.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '}' AFTER BODY OF WHILE`,
          this.prevToken.line,
          this.prevToken.col
        );
      }
    };
    this.body.push(this.currentToken);
    this.body.push({
      type: 'SEMICOLON', 
      value: ';'
    });
    this.next()

    if (this.currentToken) {
      this.errorHandler.throw(
        `UNEXPECTED TOKEN AFTER WHILE STATEMENT`,
        this.currentToken.line,
        this.currentToken.col
      );
    };
  };


  execute() {
    this.splitBlock();
    let max = 1000;
    this.evaluator.load(this.expression);
    while (!!this.evaluator.evaluate().value) {
      this.parser.load(this.body);
      this.parser.parse();
      this.evaluator.load(this.expression);
      max--;
      if (max <= 0) {
        this.errorHandler.throw(
          `MAXIMUM NUMBER OF LOOPS EXCEEDED`
        );
        break;
      };
    };
  };
};

class FunctionStmt {
  constructor(statement, evaluator, environment) {
    this.evaluator = evaluator;
    this.environment = environment;
    this.errorHandler = new ErrorHandler();

    this.statement = statement;

    this.identifier = null;
    this.args = [];
    this.body = [];

    this.index = 1;
    this.currentToken = this.statement[this.index];
    this.prevToken = null;

    this.execute();
  };

  next() {
    this.prevToken = this.statement[this.index];
    this.index++;
    this.currentToken = this.statement[this.index];
  };

  splitBlock() {
    this.identifier = this.currentToken.value;
    this.next();
    if (!this.currentToken || this.currentToken.type != 'BAR') {
      this.errorHandler.throw(
        `EXPECTED '|' AFTER FUNCTION DECLARATION`,
        this.prevToken.line,
        this.prevToken.col
      );
    };
    this.next();

    while (this.currentToken && this.currentToken.type != 'BAR') {
      this.args.push(this.currentToken);
      this.next();
      if (!this.currentToken) {
        this.errorHandler.throw(
          `EXPECTED '|' AFTER ARGUMENT LIST`,
          this.prevToken.line,
          this.prevToken.col
        );
      };
      if (this.currentToken.type != 'COMMA' && this.currentToken.type != 'BAR') {
        this.errorHandler.throw(
          `EXPECTED ',' AFTER ARGUMENT`,
          this.prevToken.line,
          this.prevToken.col
        );
      }
      if (this.currentToken.type == 'BAR') {
        break;
      };
      this.next();
    };

    this.next();

    if (!this.currentToken || this.currentToken.type != 'FATARROW') {
      this.errorHandler.throw(
        `EXPECTED '=>' AFTER FN DECLARATION`,
        this.prevToken.line,
        this.prevToken.col
      );
    };
    this.next();

    this.body = this.statement.slice(this.index);
    this.body.push({
      type : 'SEMICOLON',
      value : ';',
    });
  };

  execute() {
    this.splitBlock();
    const zapFunction = new ZapFunction(
      this.identifier, 
      this.args, 
      this.body, 
      this.environment
    );
    this.environment.define(this.identifier, zapFunction);
  };
};

class Parser {
  constructor (environment) {
    this.environment = environment
    this.evaluator = new Evaluator(this.environment);
    this.errorHandler = new ErrorHandler();
    this.log = globalLog;


    this.tokens = null;
    this.index = null;
    this.currentToken = null;
    this.previousToken = null;

    this.statements = [];
    this.currentStatement = [];

    this.openingBrace = 0;
    this.closingBrace = 0;
  };

  load(tokens) {
    this.tokens = tokens;
    this.index = 0;
    this.currentToken = this.currentToken = this.tokens[this.index];
    this.previousToken = null;

    this.openingBrace = 0;
    this.closingBrace = 0;

    this.checkBrace();
  }

  resetCurrentStatement() {
    this.currentStatement = [];
  }

  checkBrace() {
    if (this.currentToken) {
      if (this.currentToken.type == 'LBRACE') {
        this.openingBrace++;
      };
      if (this.currentToken.type == 'RBRACE') {
        this.closingBrace++;
      };
    };
  };

  next() {
    this.index++;
    this.currentToken = this.tokens[this.index];
    this.previousToken = this.tokens[this.index-1];

    this.checkBrace();
  };

  isInBlock() {
    return this.openingBrace != this.closingBrace;
  };

  isSemicolon() {
    return this.currentToken.type == 'SEMICOLON';
  };

  handleBlock(statement) {
    let stmt = new BlockStmt(
      statement,
      new Environment(this.environment),
    );
    // console.log(stmt);
    return stmt;
  };

  handlePrint(statement) {
    let stmt = new PrintStmt(
      statement,
      this.evaluator,
      this.log,
    );
    // console.log(stmt);
    return stmt;
  };

  handleDeclaration(statement) {
    let stmt = new DeclarationStmt(
      statement,
      this.evaluator,
      this.environment,
    );
    // console.log(stmt);
    return stmt;
  };

  handleIf(statement) {
    // console.log(statement);
    let stmt = new IfStmt(
      statement,
      this.evaluator,
      this.environment
    );
    // console.log(stmt);
    return stmt;
  };

  handleExpression(statement) {
    let stmt = new ExprStmt(
      statement,
      this.evaluator,
    );
    // console.log(stmt);
    return stmt;
  };

  handleWhile(statement) {
    let stmt = new WhileStmt(
      statement,
      this.evaluator,
      this.environment
    );
    // console.log(stmt);
    return stmt;
  }

  handleFunction(statement) {
    let stmt = new FunctionStmt(
      statement,
      this.evaluator,
      this.environment
    );
    // console.log(stmt);
    return stmt;
  }

  handleStatement(statement) {
    // console.log(statement);
    if (statement[0].type == 'LBRACE') {
      return this.handleBlock(statement)
    };

    if (statement[0].type == 'SHOW') {
      return this.handlePrint(statement);
    };

    if (statement[0].type == 'DECLARATOR') {
      return this.handleDeclaration(statement);
    };

    if (statement[0].type == 'IF') {
      return this.handleIf(statement);
    };

    if (statement[0].type == 'WHILE') {
      return this.handleWhile(statement);
    };

    if (statement[0].type == 'FUNCTION') {
      return this.handleFunction(statement);
    };

    return this.handleExpression(statement);
  };

  parse() {
    while (this.currentToken) {
      if (!this.isInBlock())
      {
        if (!this.isSemicolon()) {
          this.currentStatement.push(this.currentToken);
        } else {
          let stmt = this.handleStatement(this.currentStatement);
          this.statements.push(stmt);
          this.resetCurrentStatement();
        };
        this.next()
        continue;
      } 
      else 
      {
        this.currentStatement.push(this.currentToken);
        if (!this.isInBlock()) {
          let stmt = this.handleStatement(this.currentStatement);
          this.statements.push(stmt);
          this.resetCurrentStatement();
        };
        this.next();
      };
    };

    if (this.currentStatement.length) {
      this.errorHandler.throw(
        'YOU MUST HAVE FORGOTTEN A SEMICOLON OR CLOSING BRACE',
        this.previousToken.line,
        this.previousToken.col
      );
    };

    return this.statements;

  };
};



class ZapFunction {
  constructor(name, args, body, environment) {
 

    this.errorHandler = new ErrorHandler();
    this.environment = new Environment(environment);
    this.parser = new Parser(this.environment);
    this.name = name;
    this.args = args;
    this.body = body;
    this.arity = args.length;
  };

  call(args) {
    if (args.length != this.args.length) {
      this.errorHandler.throw(
        `INVALID NUMBER OF ARGUMENTS PASSED TO ${this.name}`,
      )
    };

    for (let i=0; i < args.length; i++) {
      this.environment.define(this.args[i]['value'], args[i]);
    };
    
    this.parser.load(this.body);
    this.parser.parse();
  };
};










    
class Zap {
        constructor(input) {
            this.input = input;
            this.interpreter = new Interpreter(this.input);
        }
    }
    













 
 let tokens=[];
 function  tokenizer (input){
  
    
    let current=0;
    let tokens=[];
  
  
   
    
    while (current < input.length) {
    let char = input[current];
    if (/\s/.test(char)) {
    current++;
    continue;
    }
    
    const NUMBER_REGEX = /[0-9]|\./;
    if (NUMBER_REGEX.test(char)) {
    let value = '';
    while (NUMBER_REGEX.test(char)) {
    value += char;
    
    char = input[++current];
   
    }
  
    tokens.push({ type: 'number', value });
    continue;
    }
    
    const LETTER_REGEX = /#|[a-zA-Z_]|,.+=-*\//;
    if (LETTER_REGEX.test(char)) {
    let value = '';
    while (LETTER_REGEX.test(char) || char === '#') {
    value += char;
    char = input[++current];
    }
    
    if (value.startsWith('#')) {
    tokens.push({ type: 'variable', value: value.substring(1) });
    } else if (value==='tan'||value==='sin'||value==='cos'||value==='funga'||value==='fungua'||value==='Data'||value==='andika'||value==='thibitisha'||value==='prompti'||value==='kwakila'||value==='weka'||value==='mwisho'||value==='kwenye'||value==='tafuta'||value === 'kazi' || value === 'onesha' || value=='wakati'||value === 'ikiwa' || value === 'kama'||value=='namba'||value=='sentensi'||value=='wakati'||value=='Math'||value==='chukua'||value==='async'||value==='await'||value==='rudisha'||value==='vib') {
    
    tokens.push({ type: 'keyword', value });
    }
    else if (value==='++'||value==='--'||value==='*='||value==='-='||value==='/='){
    
    
    tokens.push({ type: 'DO', value });
    
    }
    
    
    
    
    else if (value === 'elementi') {
    
    tokens.push({ type: 'elementi', value });
    } else if (value === 'sikiliza') {
    tokens.push({ type: 'sikiliza', value });
    } else {
    
    tokens.push({ type: 'identifier', value });
    }
    
    continue;
    }
    
    const OPERATOR_REGEX = /[`\;\*\-\~\=\|.\:'!\+~|&#$@\-*/%?=,\\\(<>),{.#};" \""\_\n \[ \]]/;
    if (OPERATOR_REGEX.test(char)) {
    
    tokens.push({ type: 'operator', value: char });
    
    
    
    current++;
    continue;
    }
    
    
    throw new TypeError('Unknown character: ' + char );
    }
    
    return tokens;
    }
    
    
    
    
   
 
   
 
 
   
   
   
   
   
   
   
   
   
   
   
   
   function parser(tokens) {
    let current = 0;
    
    
    var ST={op:0,
    all:false,
    aa:false,
      
    };
    
    
    function parseExpression() {
    let token = tokens[current];
     
       if(tokens[current].type==='identifier' && tokens[current+1].value==='.'){
    
   
   //something like a.length;_bb.v;
   
   
   
   
      if (tokens[current].type === 'identifier' && tokens[current+1].value === '.'&&tokens[current+2].value!='weka') {
    let val=''
    
    while(tokens[current].value!=';'){
    
    val+=tokens[current].value
    current++;
    }
    
    
    current++
    
    return{type:'ObjCall',val}
    
    }
    
    
    
    
    
 
    let pushV=''
    let kwakila=''
    let Arrname=tokens[current].value;
    
    current+=2;
    
    if(tokens[current].type=='keyword'){
    
    
    if(tokens[current].value==='weka'){
    current+=2;
    
    while(tokens[current].value!=')'){
    pushV +=tokens[current].value;
    current++;
    }
    
    
    
    }
    else if(tokens[current].value==='kwakila'){
    
    kwakila=tokens[current].value;
    current+=2;
    
    while(tokens[current].value!=')'){
    pushV +=tokens[current].value;
    current++;
    }
    
    
    
    }
    
    
    
    
    
    
    
    
    }
    current+=1;
    
    
    return{type:'push',Arrname,pushV}
    }
    
    
    
  
    
   else  if(tokens[current].type==="identifier" && tokens[current+1].value==="["){
    
    
    let Arrname=tokens[current].value;
    let arrIndex='';
    let after=''
    current+=2;
    
    if(tokens[current].value!=']'){
    
    while(tokens[current].value!=']'){
    
    arrIndex +=tokens[current].value
    current++;
    
    }
    
    
    current++
    
   
    if(tokens[current].value==='='){
    current++
    while(tokens[current].value!=';'){
    
    after+=tokens[current].value;
    current++
    
    }
    current+=1
    
    }
   
    
    
 
    }
  
   
    
    return{type:'xx',Arrname,arrIndex,after}
    }
    
    
    
    
    
    
    
    
    
  else  if (tokens[current].type === 'number' || tokens[current].type === 'variable'||( tokens[current].type==='identifier' && tokens[current+1].value !="=" && tokens[current+1].value!='(')||tokens[current].type==='"') {
    
    
    let value=''
    if(token.value==='"'){
    value+='"'
    current++
    while(token.value !=='"'){
    value=tokens[current].value
    current++
    }
    value+='"'
    
    
    }
    value=tokens[current].value
    
    
    current+=1;
    
    return { type: 'Literal',value };
    
    
    } 
    
    
    

else  if(tokens[current].type==='identifier' && (tokens[current+1].value==='('||tokens[current+3].value==='(' &&tokens[current+2].type!='keyword')){

let args=''
let name=''

if(tokens[current+1].value==='('){
name=tokens[current].value;

current+=1;
if(tokens[current].value=='('){
current+=1;


 args=parseArgumentList()
current++
}}
else{
  while(tokens[current].value!='('){
    
    name+=tokens[current].value
    current++
  }
  current+=1
  args=parseArgumentList()
  current++
}
//current+=2;
//alert(tokens[current].value)
return{type:'funcCall',name,args}
}


    
    
 
    
else  if(tokens[current].type==='identifier' && (tokens[current+1].value==='+'||tokens[current+1].value==='-'||
tokens[current+1].value==='/'||
tokens[current+1].value==='%')){
  
  let body=''
  while(tokens[current].value!=';'){
    body+=tokens[current].value;
  current++
    
  }
  current++
  return{type:'math',body}
}
    
  
    
    
    
    
    
    
    
       else if(tokens[current].type==='identifier' && tokens[current+1].value==='{'){
    
    let ObjV=''
    let Objname=tokens[current].value;
    
    current+=1;
    
  
     
       
       
       
let body = ""
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
    
 body+=tokens[current].value
 current++
  }
  
  while (ST.op != 0) {
  
   if (tokens[current].value == "{") {
 ST.op+=1;
     body+=tokens[current].value
     current++
    }
    
    body+=tokens[current].value
    
    if (tokens[current].value == "}") {
      ST.op -= 1;
      
      
    }
    
  
  
    current++
  
  }
  
  
  
  if (ST.op === 0) {
   
       
       
       
       
       return{ type:'ObjData',Objname,body}}
    
    }
    
    
    
    
    //here thers modification buss
    
    
    else if(tokens[current].type==='identifier' && tokens[current+1].value==='='){
      
      
      
      let isFetch=false
      var p=false;
    let isAngle=false
    let angleName=''
   
    let v2='';let v1=tokens[current].value;
    current+=2;
    if(tokens[current].type=='identifier'||tokens[current].type==='elementi' ||tokens[current].type==='keyword'||tokens[current].type==="operator"||tokens[current].type==="number"){
      

      
      
    if((tokens[current].value==='cos')||(tokens[current].value==='sin')){
    isAngle=true;
    
    
    angleName=tokens[current].value;
  v2=parseExpression()
  
  
  
//  alert(v2)
  //alert(tokens[current].value)
  //remember to work with noe
  }
  else if(tokens[current].type=="keyword"&&tokens[current].value==='await'){
    isFetch=true
   
   //while(tokens[current].value!=";"){
    v2=parseExpression()
    
    current++
   // alert(tokens[current].value)
    v2=parseExpression()
    
    //current++
  // }
   // current++
  //  alert(tokens[current].value)
  // alert(v2.arg)
//alert(v22)
//v2=`${v2} ${v22 }`
}
  else{
  //current++
  
  if(tokens[current].value==='prompti'){
  p=true;
  v2=parseExpression()
  
  }
  if(tokens[current].value==='thibitisha'){
  
  v2=parseExpression()
  
  }
  
  
    while(tokens[current].value!=';'){
    
    v2+=tokens[current].value
    current++
    
   
    }
    
    current++
    
  }
    
 

    }
    
  
  //current+=1;


    return{type:'Assignment',v1,v2,isAngle,isFetch,angleName,p}
    }
    
    
    
    
    //above was a modification with no bound ****
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    //theres a modification above
    
    
    
    
    
    else if (token.type === 'keyword' &&(token.value === 'andika'||token.value === 'thibitisha' ||token.value === 'prompti'||token.value === 'onesha'||token.value === 'funga'||token.value === 'fungua')) {
    
    var met=tokens[current].value;
    current++;
    
    let expression=""
    let isString=false
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    
    current++;
   
   if(tokens[current].type=="operator" && tokens[current].value==='"'){
   
   
   expression=""
   isString=true;
   current++
   while(tokens[current].value!=='"'){
   
   expression+=tokens[current].value
   current++
   
   
   }
   current++
   
   }
    if(tokens[current].type==="identifier"){
    
  
   
    
    
    
    expression =parseExpression();
    
    
    }
    
    if(tokens[current].type==="number"){
    
    
    
    
    
    
    expression =parseExpression();
    
    
    }
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
 
    current+=1;
    
    if(met==='onesha'){
    
  return { type: 'PrintStatement', value:expression,isString};
    
    }else if(met==='andika'){
    
    
    
    return { type: 'andika', value:expression,isString};
    
    }else if(met==='thibitisha'){
    
    
    
    return { type: 'thibitisha', value:expression,isString};
    
    }else if(met==='prompti'){
    
    
    return { type: 'prompti', value:expression,isString};
    
    }
    else if(met==='funga'){
    
    
    return { type: 'funga', value:expression,isString};
    
    }
    else if(met==='fungua'){
    
    
    return { type: 'fungua', value:expression,isString};
    
    }
    
    
    
    } else {
    throw new SyntaxError('Missing closing parenthesis  ');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    }
    
    
    //#####here.   alert()  thers modification in this room###
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //#######some matha values has been added today#########
    
    else if (token.type === 'keyword' && token.value === 'namba') {
    
    
    current++;
    let value,name=tokens[current].value;
    
    current++;
    
    
    if(tokens[current].value=="="){
    
    current++;
    
    value=tokens[current].value
    
    }
    current+=1
    
    return {type:'_D',name,value}
    }
    
    
    //here there is modification
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'cos'|| tokens[current].value ==='sin'|| tokens[current].value ==='tan' ||tokens[current].value ==='randam') {
    
  
    let angle=tokens[current].value;
    
    let expression=""
    current++
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    
    if(tokens[current].type==="identifier"){
   
   
   
  while(tokens[current].value!=')'){
    expression+=tokens[current].value;
    current++
    
   }
   
    
    }
    
   
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    
    current+=1;
    //alert(tokens[current].value)
    return { type: 'mathAngle',angle,expression};
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    }
    
    
    
    
    else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    }
    
    
    
    
    
   
    
    
    
    
    
    
    
    
    
     
    
    
    
    
    
    
    
    
    
  
    else if (token.type === 'keyword' && token.value === 'Data') {
    
    
    current++;
    let value='';
    let name=tokens[current].value;
    
    current++;
    
    
    if(tokens[current].value=="{"){
    
    current++;
    
    while(tokens[current].value!='}'){
    
    
    value +=tokens[current].value
    
  current++;
    }
    
    current+=1;
    
    
        return {type:'Obj',name,value}
    }
    
    
    
    
else if(tokens[current].value=="[" && tokens[current +1].value==="]"){
    
    current+=2;
    
    
    return {type:'Arr',name}
    }
    







    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if (token.type === 'keyword' && token.value === 'sentensi') {
    current++;
    let name=tokens[current].value;
    let string=""
    current++;
    
    let value
    if(tokens[current].value=="="){
    
    current++;
    }
    
    value=tokens[current].value
    
    
    if (value === '"') {
    
    current++
    
    
    while (tokens[current].value !== '"') {
    string += tokens[current].value
    
    
    current++
    
    }
    
    
    current+=1
    
    
    
    }
    
    
    return {type:'v',name:name,string}
    }
    
    
    
    //here theres modification
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if (token.type === 'elementi' && token.value === 'elementi') {
    
    var isD=false
    
    
    
    
    
    
    let elementMethod= token.value;
    current++
    if(tokens[current].value=="("){
    current++;
    
    
    
    let value=tokens[current].value
    
    
    
    if (value === '"') {
    
    
    let string = '';
    let selectorType=''
    
    while (tokens[current++] !== ',') {
    
    selectorType += tokens[current].value;
    
    
    
    break;
    
    }
    
    
    current+=1
    
    while (tokens[current++] !== '"' && tokens[current].value!=',') {
    
    string += tokens[current].value;
    
    
    
    break;
    
    
    
    }
    
    
    let strin,body,args
    
    let method=tokens[current + 3].value
    
    if(method=="."){
    current+=4;
    let methods=tokens[current].value
    
    
    if(tokens[current].value=='stailiRangi'||'kontentiNdani'||'kontenti'||'stailiRangiElementi'||'stailiUre'||'stailiUp'||'stailiMwonekano'||'sikilizaTukio'||'choraMstari'||'lineTo'||'kanvaStaili'||'kanvaMstatili'||'kanvaManeno'||'kontexti'||'kanvaFonti'||'kanva' ){
    
    let valuex =tokens[current+2].value;
    if(valuex.startsWith('"')){
   current+=3;
   
   while(tokens[current].value!='"'){
   
   valuex +=tokens[current].value
   current++;
  
   }
   valuex +='"'
  
    isD=true;
    }
    
    if(tokens[current].value=='sikilizaTukio'){
    current+=2;
    
    let value=tokens[current].value
    
    let event="";
    if (value === '"') {
    
    while (tokens[current++] !== ',') {
    
    event+= tokens[current].value;
    
    
    
    break;
    
    }
    
    
    
    current+=1
    
    
    
    
    while (tokens[current++] !== '"' && tokens[current].value!=',') {
    
    
    
    
    break;
    
    
    
    }
    
    current++
    
    strin=tokens[current].value
    if(strin=="kazi"){
    current+=2;
    
    args=parseArgumentList()
    current+=1;
    
    
    
    
    
    
let body = []
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
  }
  
  while (ST.op !== 0) {
  
    if (tokens[current].value == "{") {
  
      body.push(parseExpression())
      current++
    }
 
    body.push(parseExpression())
    if (tokens[current].value == "}") {
      ST.op -= 1;
      body.push(parseExpression())
      current++
    }
    //  
  
  
    //current++
  
  }
  
  
  
  if (ST.op === 0) {
    //alert(body)
  
 
  
  
    
    }
    
    
    
    
    
    current+=2;
  //  alert(isD)
    return {type:'elem',selectorType,args,body,event,string}
    
    }
      
      
    }}
    
    
    else if(tokens[current].value==="kontexti"){
      let m=''
      let cv=""
      let mv=""
      current+=2
      while(tokens[current].value!=')'){
        cv+=tokens[current].value
        
        current++
        
      }
      current+=2
      
      if(
        tokens[current].value==='kanvaMstatili'
      ||
        tokens[current].value==='kanvaStaili'
      
      ||
        tokens[current].value==='kanvaText'
      
      ||
        tokens[current].value==='jaza'
      
     ||
        tokens[current].value==='kanvaFonti'
      ||tokens[current].value==='kanvaManeno'
      
      ){
        m=tokens[current].value
        
        current+=2
        while(tokens[current].value!=')'){
          
          mv+=tokens[current].value
          
          current++;
          
        }
        current++
        
        
        
        
       
        
       
      }
      
      
      
      
      
      
      
      
      
      
      
      
      
      
       
        return{type:'canva',cv,mv,m,selectorType,string}
        
      
      
    }
    
    
    
    
    
    
    
    
    
    
    else{
    if(isD){
   
    current+=1}else{current+=3;}
   
   
    
   if(tokens[current].value==')'){
   
  
    current++
  
  
    
    return { type:'Elementi',selectorType,string,methods,valuex,isD}
    
   } } 
    
    
    
    }
    
    
    else{
    
    
  
  
    
    
    return{   type:'El',selectorType,string,}
    
    
    }
    
    
    }
    
    
    
    }
    
    
    
    
    }
    
    }
    
    
    
   
    
    
    
    else if (token.type === 'keyword' && token.value === 'kazi') {
    
  
    current++;
    if (tokens[current].type === 'identifier') {
    let functionName = tokens[current].value;
    current++;
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    let arguments = parseArgumentList();
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    current+=1;
    
    

    
    
    
    
    
    
let body = []
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
  }
  
  while (ST.op !== 0) {
  
    if (tokens[current].value == "{") {
  
      body.push(parseExpression())
      current++
    }
 
    body.push(parseExpression())
    if (tokens[current].value == "}") {
      ST.op -= 1;
      body.push(parseExpression())
      current++
    }
    //  
  
  
    //current++
  
  }
  
  
  
  if (ST.op === 0) {
    //alert(body)
  
 
  
  

    
    
    
    
    
    return { type: 'FunctionDeclaration', name: functionName, arguments,body }};
   
   
   
   
   
   
   
   
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    } else {
    throw new SyntaxError('Missing function name');
    }
    }
    
    
    
    
    
        else if (tokens[current].type === 'keyword' && tokens[current].value === 'async') {
    let val=tokens[current].value
    current++
    return{type:'async',val}
          
        }
    
    
    
    
        else if (tokens[current].type === 'keyword' && tokens[current].value === 'await') {
          
    let val=tokens[current].value
    
    return{type:'await',val}
          
        }
    
    
    
    
    
        else if (tokens[current].type === 'keyword' && tokens[current].value === 'rudisha') {
         
          current++
          var val=""
          if(tokens[current].type==='operator'&&tokens[current].value==="{"){
            while(tokens[current].value!='}'){
    val+=tokens[current].value
            current++
            }
            val+=tokens[current].value
          current++
           // alert(val)
          }else if(tokens[current].type==='identifier'){
            val=tokens[current].value
          
          
    current+=2
            
          }
    //alert(tokens[current].value)
 //  alert(val)
    return{type:'return',val}
          
        }
    
    
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'chukua') {
    
    current++
    if(tokens[current].type==='operator' && tokens[current].value==='('){
   var arg=""
    current++
    while(tokens[current].value!==';'){
    arg=parseArgumentList()
    current++
    }
    }
    
    
  current++
  
    return{type:'fetch',arg}
    
    
    
    
    }
    
    
    
    
   ///here
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  
    
  
    
  else if ( tokens[current].value == '{') {
   let v=''
    if(ds.ax){
      v=':'
    }else{
    
    v = tokens[current].value}
    
    return { type: 'opbrace', v }
  
  }
    else if(tokens[current].value=='}'){
     
     let v=''
      if(ds.ax){
        v='break;'
      }else{
        v=tokens[current].value}
     
      return{type:'clbrace',v}
    }
    
    
    
    else if (token.type === 'keyword' && token.value === 'ikiwa') {
      
    current++;
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current+=2
    
  
    let initName=""
    while(tokens[current].value!=";"){
      initName+=tokens[current].value;
      current++
    }
    
    
   
    
    
    
    let initialization=initName;
    
    
    
    
    current+=1
    let condition=""
    while(tokens[current].value!==';'){
  
    condition += tokens[current].value;
    
    
    current++}
    
    current+=1
    let update =""
    while(tokens[current].value!==')'){
    
    
    update+=tokens[current].value
    current++}
    
    
    
    
    
    
    
    
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    current+=1;
    let body=[]
    let ST={op:0};
if(tokens[current].value==='{'){
  ST.op+=1;
}
    
   while(ST.op!==0){
     
     if (tokens[current].value == "{") {
       
           body.push(parseExpression())
        current++ }
        
     body.push(parseExpression())
     if(tokens[current].value=="}"){
       ST.op-=1;
       body.push(parseExpression())
       current++
   }
   //  

  
  //current++
   
   }
      
   
   
   if(ST.op===0){
    //alert(body)
    return { type: 'for',initialization,condition,update,body };}
    } 
    
    
    else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    }
    
    
    
    
    
    
    
    
    
    else if (token.type === 'keyword' && token.value === 'wakati') {
    let body=""
    current++;
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    
    
    
    let condition =""
    
    while(tokens[current].value!==')'){
    
    condition +=tokens[current].value
    current++}
    
    
    
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
    current+=1;
    
    
    
    let body=[]
    let ST={op:0};
if(tokens[current].value==='{'){
  ST.op+=1;
}
    
   while(ST.op!==0){
     
     if (tokens[current].value == "{") {
       
           body.push(parseExpression())
        current++ }
        
     body.push(parseExpression())
     if(tokens[current].value=="}"){
       ST.op-=1;
       body.push(parseExpression())
       current++
   }
   //  

  
  //current++
   
   }
      
   
   
   if(ST.op===0){
    //alert(body)
   
    
    
    return { type: 'while', condition, body };
   
   }
   
   
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    } 
    
    
    
    
    
    
    
    
    
    
    
    else if (token.type === 'operator' && token.value === '(' && tokens[current+1].value!==')' && ST.all===true) {
   
    current+=1
    
    let condition=''
    while(tokens[current].value!=')'){
    condition+=tokens[current].value
    
    current++
    }
    
   // current+=1
   
  
    current++
    
    
    let body = []
    let ST = { op: 0 };
    if (tokens[current].value === '{') {
      ST.op += 1;
    }
    
    while (ST.op !== 0) {
    
      if (tokens[current].value == "{") {
    
        body.push(parseExpression())
        current++
      }
      
      body.push(parseExpression())
      if (tokens[current].value == "}") {
        ST.op -= 1;
        body.push(parseExpression())
        current++
      }
      //  
    
    
      //current++
    
    }
    
    
    
    if (ST.op === 0) {
      //alert(body)
    
    
    
    
    
    
    
    
    return{type:'ElseIf',body,condition}}
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  /*  
    
    else if (tokens[current].type === 'operator' ) {
    
    current++
    }
    
    */
    
    
    
    
    
    
    
    
    
    
    
    
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if (tokens[current].type ==="operator" && tokens[current].value==="(" &&tokens[current+1].value===')' && ST.all===true) {
    
   current+=2;
    
    
    let body = []
    let ST = { op: 0 };
    if (tokens[current].value === '{') {
      ST.op += 1;
    }
    
    while (ST.op !== 0) {
    
      if (tokens[current].value == "{") {
    
        body.push(parseExpression())
        current++
      }
     
      body.push(parseExpression())
      if (tokens[current].value == "}") {
        ST.op -= 1;
        body.push(parseExpression())
        current++
      }
      //  
    
    
      //current++
    
    }
    
    
    
    if (ST.op === 0) {
     
    
    ST.all=false;
    
    
    return{type:'Else',body}}
    }
    
    
    
    
      else if (tokens[current].type === 'keyword' && tokens[current].value === 'kwenye'|| tokens[current].value === 'mwisho') {
 let a_=tokens[current].value
 if(a_=='kwenye'){
   a_='case'
 }
      else{
        a_='default'
      }
    current++
    let a=''
    while(tokens[current].value!=':'){
      a+=tokens[current].value
      current++
      
  
    }
    
    return{type:'case',a,a_}
    
      }
      
     
    
    
    
    
    
    
    
      else if (tokens[current].type === 'operator' && tokens[current].value === ':') {
        
       
       current++
      
    
    
    
    
    
      let body = []
      let ST = { op: 0 ,};
      if (tokens[current].value === '{') {
        
        ST.op += 1;
      }
      
      while (ST.op !== 0) {
      
        if (tokens[current].value == "{") {
     ds.ax=true
          body.push(parseExpression())
          current++
        }
        //alert(tokens[current].value)
        body.push(parseExpression())
        if (tokens[current].value == "}") {
          ST.op -= 1;
          ds.ax=true
          body.push(parseExpression())
          current++
        }
        //  
      
      
        //current++
      
      }
      
      
      
      if (ST.op === 0) {
        //alert(body)
     // alert(ds.ax)
      ds.ax=false
   
      
        return { type: 'todo',body}
    
    
    
    
    
    
    
    
      }
      
      
      }
      
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'tafuta') {
      
      current+=2
      let condition=''
      while(tokens[current].value!=')'){
        condition+=tokens[current].value;
        current++
        
        
      }
      
     
      current+=1;
      
      
      
      let body = []
      let ST = { op: 0,};
      if (tokens[current].value === '{') {
        
        ST.op += 1;
      }
      
      while (ST.op !== 0) {
      
        if (tokens[current].value == "{") {
      
          body.push(parseExpression())
          current++
        }
        //alert(tokens[current].value)
        
        body.push(parseExpression())
        if (tokens[current].value == "}") {
          ST.op -= 1;
          body.push(parseExpression())
          current++
        }
        //  
      
      
        //current++
      
      }
      
      
      
      if (ST.op === 0) {
        
      
      
      
      
        return { type: 'switch', condition, body }
      };
      
      
      
    }
    
    
    
    
    
    
    
    else if (token.type === 'keyword' && token.value === 'kama') {
    ST.all=true;
    current++;
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === '(') {
    current++;
    
    
    
    let condition =""
    while(tokens[current].value!==')'){
    
    condition +=tokens[current].value
    current++
    }
    
    
    
    if (tokens[current].type === 'operator' && tokens[current].value === ')') {
   
    current+=1;
  
        
  // alert(condition)
  
  
let body = []
  let ST = { op: 0 };
  if (tokens[current].value === '{') {
    ST.op += 1;
  }
  
  while (ST.op !== 0) {
  
    if (tokens[current].value == "{") {
  
      body.push(parseExpression())
      current++
    }
// alert(tokens[current].value)
    body.push(parseExpression())
    if (tokens[current].value == "}") {
      ST.op -= 1;
      body.push(parseExpression())
      current++
    }
    //  
  
  
    //current++
  
  }
  
  
  
  if (ST.op === 0) {
    //alert(body)
  
 
  
  
    return { type:  'IfStatement', condition:condition,body}};
    
    } else {
    throw new SyntaxError('Missing closing parenthesis');
    }
    } else {
    throw new SyntaxError('Missing opening parenthesis');
    }
    } 
    
    
    
    
    
 
    
    
    
    
    else {
    throw new SyntaxError('Unexpected token: ' + token.value);
    }
    
    
    
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    function parseArgumentList() {
    let arguments = [];
    
    while (tokens[current].type === 'identifier') {
    arguments.push(tokens[current].value);
    current++;
    if (tokens[current].type === 'operator' && tokens[current].value === ',') {
    current++;
    } else {
    break;
    }
    }
   // current++
    
    return arguments;
    }
    
    
    
    
    var ds={ax:false}
    
    
    
    
    
    
    
    
    function parseStatements() {
    let statements = [];
    
    
    while (current < tokens.length) {
    
    if (tokens[current].type === 'keyword' && tokens[current].value === 'onesha') {
    
    statements.push(parseExpression());
    }
    
    else if (tokens[current].type === 'DO') {
    
    statements.push(parseExpression());
    }
    
    
    
     
    
    
    
    else if (tokens[current].type === 'variable') {
    
    statements.push(parseExpression());
    }
    else if (tokens[current].type === 'identifier' && tokens[current+1].value==='.') {
    statements.push(parseExpression());
    }
    else if (tokens[current].type === 'identifier') {
    statements.push(parseExpression());
    }
    
    else if (tokens[current].value==='mwisho') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type==='operator'&&tokens[current].value===':') {
    statements.push(parseExpression());
    }
    else if ( tokens[current].type==='keyword' && tokens[current].value==='Data') {
    statements.push(parseExpression());
    }
    
    
    else if ( tokens[current].type==='keyword' && tokens[current].value==='kwenye') {
    statements.push(parseExpression());
    }
    
    
    
    
else  if(tokens[current].type==='identifier' && (tokens[current+1].value==='+'||tokens[current+1].value==='-'||
tokens[current+1].value==='/'||
tokens[current+1].value==='%')){
      statements.push(parseExpression());
    
    }
    
  
    
    
    else if(tokens[current].type=="identifier" && tokens[current +1].value=="["){
    
    
    statements.push(parseExpression());
    
    }
    
    
    
    else if (tokens[current].type === 'identifier' && tokens[current+1].value=='(') {
   
    statements.push(parseExpression());
    
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(tokens[current].type=='operator'&& tokens[current].value=='}'){
     
        statements.push(parseExpression());
      
    }
    
    
    else if(tokens[current].type=='operator'&& tokens[current].value=='{'){
     
        statements.push(parseExpression());
      
    }
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'fungua') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'funga') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'prompti') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'andika') {
    statements.push(parseExpression());
    }
    
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'fungua') {
    statements.push(parseExpression());
    }
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'thibitisha') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'kazi') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value==='chukua') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'elementi' && tokens[current].value === 'elementi') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'sikiliza' && tokens[current].value === 'sikiliza') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'tafuta') {
    statements.push(parseExpression());
    }
    
    
    
    
    
      else if (tokens[current].type === 'keyword' && tokens[current].value === 'kwenye'|| tokens[current].value === 'mwisho') {
            statements.push(parseExpression());
    }
    
 
    
      else if (tokens[current].type === 'operator' && tokens[current].value === ':') {
            statements.push(parseExpression());
    }
    
      
    

    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'namba') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'wakati') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'number') {
    statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'sentensi') {
    statements.push(parseExpression());
    }
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'sin') {
    statements.push(parseExpression());
    } 
    else if (tokens[current].type === "operator" && tokens[current].value === "(" && tokens[current + 1].value != ')' && ST.all === true) {
      statements.push(parseExpression());
    }
    
    
    
    else if (tokens[current].type ==="operator" && tokens[current].value==="(" &&tokens[current+1].value===')' && ST.all===true) {
      
  statements.push(parseExpression());}
   
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'cos') {
    statements.push(parseExpression());
    } 
    
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'await') {
    statements.push(parseExpression());
    } 
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'async') {
    statements.push(parseExpression());
    } 
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'rudisha') {
    statements.push(parseExpression());
    } 
    
    
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'ikiwa') {
    statements.push(parseExpression());
    } 
    
    else if (tokens[current].type === 'keyword' && tokens[current].value === 'kama') {
    statements.push(parseExpression());
    } else {
    throw new SyntaxError('Unexpected token: ' + tokens[current].value);
    }
    }
    
    return statements;
    
    
    
    }
    
    
    return parseStatements();
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    function generateCode(ast) {
    
    
    let code = '';
    
    let cu=0;
    function traverse(node) {
    
   
  
    
    if(node.type=="Literal"){
    
   
    
    let a=`  ${node.value}  \n`
    return code=node.value;
    
    
    }
    
    
    
    else if(node.type=="thibitisha"){
    
    if(node.isString){
    
    cu++
    return code=`  confirm("${node.value}");`
    }else{cu++
    
    return code=` confirm(${node.value.value});`;
    
    }
    
    }
    
    
    
    else if(node.type=="fungua"){
    
    if(node.isString){
    
    cu++
    return code=`  window.open("${node.value}");`
    }else{cu++
    
    return code=` window.open(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    else if(node.type=="funga"){
    
    if(node.isString){
    
    cu++
    return code=`  window.close("${node.value}");`
    }else{cu++
    
    return code=` window.close(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    else if(node.type=="andika"){
    
    if(node.isString){
    
    cu++
    return code=`  document.write("${node.value}");`
    }else{cu++
    
    return code=` document.write(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    
    
    
    
    else if(node.type=="prompti"){
    
    if(node.isString){
    
    cu++
    return code=`  prompt("${node.value}");`
    }else{cu++
    
    return code=` prompt(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    
    
    
    
    
    else if(node.type=="PrintStatement"){
     
    if(node.isString){
    
    cu++
   return code=`  alert("${node.value}");`
    }else{cu++
   
return code=` alert(${node.value.value});`;
    
    }
    
    }
    
    
    
    
    
    
    
   else if(node.type=="xx"){
   let a= node.Arrname
   let b=node.arrIndex
   let c=node.after
   
     cu++
   
    return  code=`${a}[${b}]=${c};\n`
    
     
    }
    
    
    
    
    
    else if(node.type==="math"){
     
      let z=node.body+'\n';
        
         return code=z
      }
      
      
    
    
    
    
    
    else if(node.type=="Obj"){
    
    
    let x=node.name
    let y=node.value
    cu++
    let z=`  ${x} ={ ${y} };\n`
    
    return code=z
    
    
    }
    
    
    
    else if(node.type=="Arr"){
    
    
    let x=node.name
    
    let z=`const ${x} =[];\n`;
    
    cu++
    return code=z;
    
    
    }
    
    
    else if(node.type=="ObjCall"){
    
    
    let x=` \n ${node.val}  `
    
    
    
    cu++
    
    return code=x;
    
    
    }
    
    
    
    else if(node.type=="push"){
    
    
    let x=node.Arrname
    let y=node.pushV;
    
    let z=`${x}.push(${y});\n`;
    
    return code=z;
    
    
    }
    
    
    
    
    else if(node.type=="Assignment"){
    let c=''
    let z=''
    let y=''
    
    let x=node.v1
     
    
    
    
    if(node.isFetch){
     
    
    y=`  ${node.v1}=${traverse(node.v2)}  ;\n`
      
     return code=y
    }
    

    if(node.isAngle){
      
      
      
    let y=node.v2.expression
    let a=node.angleName
    z=`${x}=Math.${a}(${y}); \n`
    
    
    }
    else{
    
    if(node.p){
    c = traverse(node.v2)
    
    
    
    y=c;
    
    z=`${x}=${y} \n`
    
    return code=z
    }
    else if(!node.p){
    
   
    c = node.v2
    
    y=c;
    
    z=`${x}=${y}  \n`
    return code=z
    }
    
   
    y=node.v2
    
     z=`${x}=${y};  \n`
     }
     cu++
     
    return code=z;
    
    
    }
    
    
    
    
    else if(node.type=="mathAngle"){
    
    
    let x=node.angle
    let y=node.expression
    
    let z=`Math.${x}(${y});\n`
   
    return code=z;
    
    
    }
    
   
   
   
   
   
   
   
   
   
   
   
   
   
    else if(node.type=="switch"){
     
     let d=node.condition
     let a = 0
     let c = ''
     
     function xyz() {
       //traverse(ast[a])
     
       c += traverse(node.body[a])
       // alert(c)
     }
     while (a < node.body.length) {
     
       xyz()
       a++
     
     }
     
     
     let co=`switch(${d}) ${c}`
     
     
     
     
      return code =co
    }
    
    
   
   
   
   
   
   
   
    else if(node.type=="case"){
     let d=`${node.a_} ${node.a}`
      return code =d
    }
    
   
   
   
    else if(node.type=="todo"){
     
     
     
    
     let a = 0
     let c = ''
     
     function xyz() {
       //traverse(ast[a])
     
       c += traverse(node.body[a])
       // alert(c)
     }
     while (a < node.body.length) {
     
       xyz()
       a++
     
     }
     
     
      return code =c
    }
    
   
   
   
    else if(node.type=="fetch"){
     
     
     
   return code =`await fetch(${node.arg})`
    
    }
    
    
    else if(node.type=="async"){
     
     
     
      return code =` ${node.val}   `
    }
    
    
    
    else if(node.type=="await"){
     
   
     
      return code =`     ${node.val}   `
    }
    
    else if(node.type=="return"){
     
     
     
      return code =`return  ${node.val} \n`
    }
    
    
    
    
    else if(node.type=="opbrace"){
     
     
     
      return code =`${node.v}\n`
    }
    
    
    
    else if(node.type=="clbrace"){
     
      return code =`${node.v}\n`
    }
    
    
    
    else if(node.type=="_D"){
    
  
    
    return  code=`
    var ${node.name} =${node.value};\n`;
    
    
    }
    else if(node.type=="v"){
    
   
    
    return code=`var ${node.name} ="${node.string}";\n`;
    

    }
    
    
    
    else if(node.type=="FunctionDeclaration"){
    

let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
  
     
    return code = `function ${node.name}(${node.arguments.join(', ')}) ${c}\n`;
    
    }
    
    
    else if(node.type=="funcCall"){
    
   return code = ` ${node.name}(${node.args});\n`
   
    
    }
    
    
    
    
    
    
    else if(node.type=="IfStatement"){
    
    
    
    
    
    
    

let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
   
    
    
    
    
    
    return   code = `    \n if (${node.condition}) ${c}     \n`;
   
   
   
    }
    
    
    
    
    
    
    
    
    else if(node.type=="Else"){
    
let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
    
    return  code =` else ${c}\n`;
    }
    
    
    
    
    else if(node.type=="ElseIf"){
    
    
    
let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
    
    
    
    return code = `else if(${node.condition})${c}  `;
    
    
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(node.type=="while"){
    
    
      let v= `while (${node.condition})`
      

    let a=0
    let c=''
    function xyz(){
      //traverse(ast[a])
      
      c+=traverse(node.body[a])
     // alert(c)
}
    while(a<node.body.length){
      
      xyz()
      a++
      
    }
    
   let b=`${v}${c} \n`
   return c=b;
    }
    
    
    
    /*
    else if(node.type=="fetch"){
    
    return code+= `fetch(${node.url}, {
    method: '${node.method}',
    headers:${node.meta},
    body: JSON.stringify(${node.body})
    })
    .then(${node.args}=> ${node.res}).then(${node.args2}=> {
    
    ${node.res2}
    })`
    
    
    
    
    
    
    }
    */
    
    
    
    
    
    
    
    else if(node.type==='canva'){
    //  alert(node.string)
    let z=""
    let s=false
     let a=`document.querySelector("#${node.string}")`
     let b=''
    if (node.m==='kanvaStaili'){
      b='fillStyle'
      s=true
    }else if(node.m==='jaza'){
      b='fill'
    }else if(node.m==='kanvaFonti'){
      
      
      b='font'
      s=true
    }else if(node.m==='kanvaManeno'){
      
      
      b='fillText'
   
    }else if(node.m==='kanvaMstatili'){
      
      
      b='fillRect'
    }else{}
    
    
    if(s){
      
      
      z=`${a}.getContext(${node.cv}).${b}=${node.mv};\n`
      
    }else{
      
      z=`${a}.getContext(${node.cv}).${b}(${node.mv});\n`
      
    }
    
    
  //  alert(b)
 //    alert(z)
     return code=z
     
    }
    
    
    
    
    else if(node.type=="Elementi"){
    
    let m=node.methods
    
    let v=""
    v=node.valuex;
    
    
    let sel =node.selectorType;
    
    
    
    
    if(sel=="id"){
    let res=""
    if(m=="stailiRangi"){
    
    res  ='style.color ='
    
    }
    else if(m=="stailiRangiElementi"){
    res='style.backgroundColor='}
    else if(m=="stailiUre"){
    res='style.height='}
    else if(m=="stailiUp"){
    res='style.width='}
    
    else if(m=="stailiMwonekano"){
    res='style.display='
    if(node.value=="onekana"){
    v=" "}
    if(node.value=="usionekane"){
    v="none"
    }
    }
    else if(m=="kontentiNdani"){
    
    
    res='innerHTML='  }
    else if(m=="kontenti"){
    res ='value'}
    else if(m=="sikilizaTukio"){
    
    }else {}
    
    if(m =="kontentiNdani"){
    
    
    
    
       return code = `document.querySelector("#${node.string}").${res}${v};`;
    
    
  
    
    }else{
    
    return code +=`document.querySelector("#${node.string}").${res} "${v}";`;}
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(sel=="class"){
    let res=""
    if(m=="stailiRangi"){
    
    res  ='style.color ='
    
    }
    else if(m=="stailiRangiElementi"){
    res='style.backgroundColor='}
    else if(m=="stailiUre"){
    res='style.height='}
    else if(m=="stailiUp"){
    res='style.width='}
    
    else if(m=="stailiMwonekano"){
    res='style.display='
    if(node.value=="onekana"){
    v=" "}
    if(node.value=="usionekane"){
    v="none"
    }
    }
    else if(m=="sikilizaTukio"){
    
    }
    
    
    
    
    
    
    else if(m=="konteniNdani"){
    res='innerHTML='}
    else if(m=="kontenti"){
    res ='value'}else{
    }
    
    
    
    return   code = `document.querySelector(".${node.string}").${res}"${v}"`;
    
    }
    else if(sel=="name" ){
    
    let res=""
    if(m=="stailiRangi"){
    
    res  ='style.color ='
    
    }
    else if(m=="stailiRangiElementi"){
    res='style.backgroundColor='}
    else if(m=="stailiUre"){
    res='style.height='}
    else if(m=="stailiUp"){
    res='style.width='}
    
    else if(m=="stailiMwonekano"){
    res='style.display='
    if(node.value=="onekana"){
    v=" "}
    if(node.value=="usionekane"){
    v="none"
    }
    }
    else if(m=="konteniNdani"){
    res='innerHTML +='}
    else if(m=="kontenti"){
    res ='value'}else{
    }
    
    
    return   code = `document.querySelector("${node.string}").${res}${v}`;
    
    }
    
    
    }
    
    else if(node.type=="elem"){
      
      
    if(node.selectorType=="id"){
    
    
    
    

let a = 0
   let c = ''
   
   function xyz() {
    
     
     
     //traverse(ast[a])
   
     c += traverse(node.body[a])
  
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
   
    
    
    
    
    
    
    
    
    
    
    return code =`document.querySelector("#${node.string}").addEventListener("${node.event}", function(${node.args.join(', ')}) ${c})`;
    }  }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    else if(node.type==='ObjData'){
      
      
      
      
      
   
   
      
      
      
      
     return code=`${node.Objname}=${node.body};\n`
     
    }
    
    
    
    else if(node.type=="for"){
     // alert('im')
   let x=node.initialization
   
   let y=node.condition
   let z=node.update
   
   
let a = 0
   let c = ''
   
   function xyz() {
     
     //traverse(ast[a])
     
   
     c += traverse(node.body[a])
   
     
   }
   
   while (a < node.body.length) {
   
     xyz()
     a++
   
   }
   
   
   
   
   
 
    cu++
  return  code=`for( var ${x};${y};${z})
      ${c}
   
  \n  `
      
      
    }
    
    
    
    
    
    
    
    
    
    else{
    
    
    // throw new Error('Unknown construct '+ 
    node.value
    
    }
    
    }
    let a=0
    let c=''
    function xyz(){
      //traverse(ast[a])
      
      c+=traverse(ast[a])
     // alert(c)
}
    while(a<ast.length){
      
      xyz()
      a++
      
    }
    
    
    return code=c}
    
  
    
    

  //document.getElementById("donut").innerHTML=day
   /* i.forEach(c=>{
      
      alert(c.type)
    })*/
    
    
    
    
    



        function Compile() {
            var inp = editor.getValue(); // Get value from CodeMirror

            // Timing the compile process
            
                
    var d=new tokenizer(inp)
    var i= new parser(d)
  var day=generateCode(i);
// console.log(day)
var kiswahiliScript=  Function(day)
 
 kiswahiliScript()
 
        }

        // Handle file creation form
        document.getElementById('fileForm').addEventListener('submit', function(event) {
            event.preventDefault();
            var fileName = document.getElementById('fileName').value;
            createFile(fileName);
        });

        // Modal functionality
        function openModal() {
            document.getElementById('fileModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('fileModal').style.display = 'none';
        }
        
        
        
        
        function toggleTerminal() {
    var editorContainer = document.getElementById('editorContainer');
    var terminalContainer = document.getElementById('terminalContainer');

    if (terminalContainer.classList.contains('hidden')) {
        editorContainer.classList.add('hidden');
        terminalContainer.classList.remove('hidden');
        document.getElementById('terminalInput').focus();
    } else {
        terminalContainer.classList.add('hidden');
        editorContainer.classList.remove('hidden');
    }
}

var isDone=false;
function executeCommand(command) {
    const terminalOutput = document.getElementById('terminalOutput');
    const args = command.trim().split(/\s+/);
    const cmd = args[0];
    const filename = args[1];

    if (cmd === 'kiswahili') {
        switch (args[1]) {
            case 'clear':
                terminalOutput.innerHTML = '';
                break;
            case 'mkfile':
                createFile(args[2]);
                terminalOutput.innerHTML += '> File created\n';
                break;
                
                
                case  'run':
                  if(!isDone){
                    terminalOutput.innerHTML+='><span>huez ku run program bila ku compail '
                  }
                  if(isDone){
                compile();
                 
                  }
            
            break;
            case 'compail':
              terminalOutput.innerHTML += '> Compilation successful\n';
              isDone=true;
              setTimeout(function(){
                terminalOutput.innerHTML += '> <br>..';
                
              },1000)
              setTimeout(function(){
                terminalOutput.innerHTML += ' .......';
                
              },1000)
              
              setTimeout(function(){
                terminalOutput.innerHTML += '> now run your program\n';
                
              },1000)
             
              break;
              
              
            case 'delete':
              delete files[filename];
            terminalOutput.innerHTML += '> File deleted\n';
            updateFileList();
            break;
              
                  
            default:
                if (args[1].endsWith('.kiss')) {
                    handleFileCommands(args[1], args[0]);
                } else {
                    terminalOutput.innerHTML += '> Unknown command\n';
                }
        }
    } else {
        terminalOutput.innerHTML += '> Unknown command\n';
    }

    // Scroll to the bottom of the terminal output
    terminalOutput.scrollTop = terminalOutput.scrollHeight;
}

function handleFileCommands(filename, command) {
    const terminalOutput = document.getElementById('terminalOutput');
    if (command === 'compile') {
        if (files[filename]) {
            // Simulate compilation
           // compile();
           alert(files[filename])
            terminalOutput.innerHTML += '> Compilation successful\n';
        } else {
            terminalOutput.innerHTML += '> Compilation error: File not found\n';
        }
    } else if (command === 'run') {
        if (files[filename]) {
            // Simulate running
            terminalOutput.innerHTML += '> Running program...\n';
            terminalOutput.innerHTML += `> ${files[filename]}\n`;
        } else {
            terminalOutput.innerHTML += '> Error: File not found\n';
        }
    } else if (command === 'delete') {
        if (files[filename]) {
            delete files[filename];
            terminalOutput.innerHTML += '> File deleted\n';
            updateFileList();
        } else {
            terminalOutput.innerHTML += '> Error: File not found\n';
        }
    } else {
        terminalOutput.innerHTML += '> Unknown file command  ${args[1]}\n';
    }
}

document.getElementById('terminalInput').addEventListener('keypress', function (event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        const command = this.value;
        executeCommand(command);
        this.value = '';
    }
});

function compile() {
            var inp = editor.getValue(); // Get value from CodeMirror

            // Timing the compile process
            const start = performance.now();

            // Simulate the creation of a new Zap instance
            const zapInstance = new Zap(inp);

        // Extract logs from the globalLog to display
        const logs = globalLog.values.map(entry => {
            if (entry.log) return entry.log;
            if (entry.error) return `Error: ${entry.error.message} at line ${entry.error.line}`;
            return '';
        }).join('<br>');
const terminalOutput = document.getElementById('terminalOutput');
        // Update the HTML to display the logs
        terminalOutput.innerHTML = logs;
            // Timing end
            const end = performance.now();
            const timeTaken = end - start;

            // Update the HTML to display the logs and timing
            terminalOutput.innerHTML = `
            kiswahiliScript with .kiss
            ========  ====== ====== =====
            
            <div>Time taken: ${timeTaken.toFixed(2)} ms</div>
            ~~~ compilation results ~~~~~~
            
            <div>${logs}</div>
            ====>time start:${start}
            ====>time end:${end}
            
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            developed by Silivestir Assey ,Isack Wagunda
            Under splannes team ©splannes 2024
            maintained by Silivestir Assey 
            -------     ----------   ----------
            see docs at kiswahiliScript page
            report bugs,disclaimer,privacy,
            
            `;
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="KiswahiliScript Documentation: A programming language for Swahili speakers with comprehensive guides in both Swahili and English. Learn programming concepts using KiswahiliScript.">
    <meta name="keywords" content="KiswahiliScript, Swahili programming language, programming documentation, Swahili coding, Silivestir Assey, Isack Wagunda">
    <meta name="author" content="Silivestir Assey, Isack Wagunda">
    <title>KiswahiliScript Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #007BFF;
        }
        .toggle-button {
            margin-bottom: 20px;
        }
        .toggle-button button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: #007BFF;
            color: #fff;
            cursor: pointer;
        }
        .toggle-button button:hover {
            background-color: #0056b3;
        }
        .content {
            display: none;
        }
        .show {
            display: block;
        }
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>KiswahiliScript Documentation</h1>
        <div class="toggle-button">
            <button onclick="toggleLanguage('sw')">Kiswahili</button>
            <button onclick="toggleLanguage('en')">English</button>
        </div>
        <div id="sw" class="content">
            <h2>Muhtasari wa KiswahiliScript</h2>
            <p>KiswahiliScript ni lugha ya programu iliyoandaliwa kwa ajili ya watu wanaozungumza Kiswahili. Hapa chini utaona maelezo ya kila kipande cha lugha:</p>
            <h3>Vikumbusho vya Lugha</h3>
            <pre>$a = 2;</pre>
            <p><strong>Maelezo:</strong> Hii inatangaza kipande cha data (variable) kinachoitwa <code>$a</code> na kumwambia kwamba thamani yake ni 2.</p>
            <pre>wakati [ a < 100 ] {
  $b = 2;
  $niNambaTasa = 0;
  wakati [ b <= a / 2 ] {
    kama [ !a % b == 0 ] {
      b = b + 1;
    } au {
      b = a;
      niNambaTasa = 1;
    };
  };
  kama [ !niNambaTasa ] {
    andika a + ' ni namba tasa';
    andika;
  };
  a = a + 1;
};</pre>
            <p><strong>Maelezo:</strong> Huu ni mfano wa kutumia <code>wakati</code> (while) kwa ajili ya kuandika mpangilio wa taratibu. Hapa tunachunguza namba na kuchapisha kama namba ni tasa.</p>
            <pre>kazi semaHabari:jina: => {
  andika 'habari ' + jina;
};</pre>
            <p><strong>Maelezo:</strong> Hii inatambulisha kazi inayoitwa <code>semaHabari</code> ambayo inachapisha salamu kwa jina lililotolewa.</p>
            <pre>$counter = 0;

wakati [ counter < 10 ] {
  andika counter;
  counter = counter + 1;
};</pre>
            <p><strong>Maelezo:</strong> Hii ni mfano wa kutumia <code>wakati</code> (while) na kuhesabu kutoka 0 hadi 9.</p>
            <pre>$jina = 'Patricia';

andika jina;</pre>
            <p><strong>Maelezo:</strong> Hii inatangaza kipande cha data kinachoitwa <code>$jina</code> na kisha kuchapisha jina hilo.</p>
            <pre>kazi kulaTikiti:: => {
  andika 'ninakula tikiti';
  idadiYaTikiti = idadiYaTikiti - 1;
  andika 'zina ' + idadiYaTikiti + ' zilizobaki';
  andika;
};</pre>
            <p><strong>Maelezo:</strong> Hii ni kazi inayoeleza matendo ya kula tikiti na kupunguza idadi ya tikiti zilizobaki.</p>
            <pre>$idadiYaTikiti = 20;

wakati [ idadiYaTikiti > 5 ] {
  kulaTikiti::;
};</pre>
            <p><strong>Maelezo:</strong> Hii ni mfano wa kutumia <code>wakati</code> (while) kuendelea kula tikiti hadi idadi ya tikiti iwe ndogo au sawa na 5.</p>
            <h3>Wasiliana na Waandishi</h3>
            <p><strong>Silivestir Assey:</strong> <a href="mailto:silivestirassey@gmx.com">silivestirassey@gmx.com</a></p>
            <p><strong>Isack Wagunda:</strong> <a href="mailto:mwlwaphysicsict@gmail.com">mwlwaphysicsict@gmail.com</a></p>
        </div>
        <div id="en" class="content">
            <h2>KiswahiliScript Overview</h2>
            <p>KiswahiliScript is a programming language created for Swahili speakers. Below you will find descriptions of each language construct:</p>
            <h3>Language Constructs</h3>
            <pre>$a = 2;</pre>
            <p><strong>Description:</strong> This declares a variable called <code>$a</code> and sets its value to 2.</p>
            <pre>wakati [ a < 100 ] {
  $b = 2;
  $niNambaTasa = 0;
  wakati [ b <= a / 2 ] {
    kama [ !a % b == 0 ] {
      b = b + 1;
    } au {
      b = a;
      niNambaTasa = 1;
    };
  };
  kama [ !niNambaTasa ] {
    andika a + ' ni namba tasa';
    andika;
  };
  a = a + 1;
};</pre>
            <p><strong>Description:</strong> This is an example of using <code>wakati</code> (while) for a loop that processes numbers and prints if a number is prime.</p>
            <pre>kazi semaHabari:jina: => {
  andika 'habari ' + jina;
};</pre>
            <p><strong>Description:</strong> This defines a function called <code>semaHabari</code> that prints a greeting with the provided name.</p>
            <pre>$counter = 0;



wakati [ counter < 10 ] {
  andika counter;
  counter = counter + 1;
};</pre>
            <p><strong>Description:</strong> This is an example of using <code>wakati</code> (while) to count from 0 to 9.</p>
            <pre>$jina = 'Patricia';

andika jina;</pre>
            <p><strong>Description:</strong> This declares a variable called <code>$jina</code> and prints its value.</p>
            <pre>kazi kulaTikiti:: => {
  andika 'ninakula tikiti';
  idadiYaTikiti = idadiYaTikiti - 1;
  andika 'zina ' + idadiYaTikiti + ' zilizobaki';
  andika;
};</pre>
            <p><strong>Description:</strong> This function describes the action of eating a ticket and decreasing the remaining ticket count.</p>
            <pre>$idadiYaTikiti = 20;

wakati [ idadiYaTikiti > 5 ] {
  kulaTikiti::;
};</pre>
            <p><strong>Description:</strong> This is an example of using <code>wakati</code> (while) to continue consuming tickets until the count is less than or equal to 5.</p>
            <h3>Contact Information</h3>
            <p>feel free to contribute by contact us</p>
            <p><strong>Silivestir Assey:</strong> <a href="mailto:silivestirassey@gmx.com">silivestirassey@gmx.com</a></p>
            <p><strong>Isack Wagunda:</strong> <a href="mailto:mwlwaphysicsict@gmail.com">mwlwaphysicsict@gmail.com</a></p>
        </div>
    </div>

    <script>
        function toggleLanguage(lang) {
            document.getElementById('sw').classList.toggle('show', lang === 'sw');
            document.getElementById('en').classList.toggle('show', lang === 'en');
        }
    </script>
</body>
</html>




<!doctype html>
<html lang=en>
<head>
<meta charset=UTF-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>kiswahiliScript</title>
<link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/codemirror.min.css>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/theme/dracula.min.css>
<script src=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/codemirror.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/mode/javascript/javascript.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/addon/edit/matchbrackets.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/addon/edit/closebrackets.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/addon/hint/show-hint.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/addon/hint/javascript-hint.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.slim.min.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.0/addon/hint/show-hint.min.css>
<style>.CodeMirror{border:1px solid #ddd;height:auto}.hidden{display:none}.file-list{display:flex;overflow-x:auto;padding:10px 0}.file-list-item{cursor:pointer;padding:10px;margin-right:10px;border-radius:4px;text-align:center;transition:background-color .3s,color .3s}.file-list-item:hover{background-color:#f1f1f1}.file-list-item.active{background-color:#007bff;color:#fff;border-bottom:3px solid #0056b3}.navbar{margin-bottom:20px}.file-list-item i{font-size:24px}#outputContainer{background:#282a36;color:#f8f8f2;padding:10px;border:1px solid #44475a;border-radius:4px;font-family:monospace;white-space:pre-wrap}.modal{display:none;position:fixed;z-index:1050;left:0;top:0;width:100%;height:100%;overflow:hidden;outline:0}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border:1px solid #999;border-radius:.3rem;outline:0;box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-header{padding:.75rem 1.25rem;border-bottom:1px solid #e9ecef}.modal-body{position:relative;padding:1.25rem}.modal-footer{padding:.75rem 1.25rem;border-top:1px solid #e9ecef;text-align:right}.modal-open .modal{display:block}</style>
</head>
<body>
<div class="container mt-4">
<div class="navbar navbar-expand-lg navbar-light bg-light">
<button class="btn btn-primary mr-2" onclick=openModal()>
<i class="fas fa-plus"></i> Create File
</button>
<button class="btn btn-warning mr-2" onclick=toggleTerminal()>
<i class="fas fa-terminal"></i> Terminal
</button>
<button class="btn btn-secondary mr-2" onclick=toggleEditor()>
<i class="fas fa-toggle-on"></i> Toggle Editor/Output
</button>
<button class="btn btn-success" onclick=saveFile()>
<i class="fas fa-save"></i> Save File
</button>
</div>
<div id=fileList class="file-list mt-2"></div>
<div id=editorContainer class=mt-2>
<textarea id=code></textarea>
</div>
<div id=terminalContainer class="mt-2 hidden">
<div id=terminalOutput class="border p-3" style=background:#000;color:#fff;font-family:monospace;height:300px;overflow-y:auto></div>
<textarea id=terminalInput class="form-control mt-2" rows=3 placeholder="Type your command here..."></textarea>
</div>
<div id=outputContainer class="mt-2 hidden">
<div id=s></div>
</div>
<div class=modal id=fileModal>
<div class=modal-dialog>
<div class=modal-content>
<div class=modal-header>
<h5 class=modal-title>Create New File</h5>
<button type=button class=close onclick=closeModal()>
<span aria-hidden=true>&times;</span>
</button>
</div>
<div class=modal-body>
<form id=fileForm>
<div class=form-group>
<label for=fileName>File Name (must end with .kiss)</label>
<input class=form-control id=fileName required>
</div>
<button type=submit class="btn btn-primary">Create File</button>
</form>
</div>
</div>
</div>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.2/dist/umd/popper.min.js></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js></script>
<script>var editor=CodeMirror.fromTextArea(document.getElementById("code"),{mode:"javascript",theme:"dracula",lineNumbers:!0,matchBrackets:!0,autoCloseBrackets:!0,extraKeys:{"Ctrl-Space":"autocomplete"}});editor.setValue("$a = 2;\n\nwakati [ a < 100 ] {\n  $b = 2;\n  $niNambaTasa = 0;\n  wakati [ b <= a / 2 ] {\n    kama [ !a % b == 0 ] {\n      b = b + 1;\n    } au {\n      b = a;\n      niNambaTasa = 1;\n    };\n  };\n  kama [ !niNambaTasa ] {\n    andika a + ' ni namba tasa';\n    andika;\n  };\n  a = a + 1;\n};\n\nkazi semaHabari:jina: => {\n  andika 'habari ' + jina;\n};\n\nsemaHabari:'Johnny':;\n\n$counter = 0;\n\nwakati [ counter < 10 ] {\n  andika counter;\n  counter = counter + 1;\n};\n\n$jina = 'Patricia';\n\nandika jina;\n\nkazi kulaTikiti:: => {\n  andika 'ninakula tikiti';\n  idadiYaTikiti = idadiYaTikiti - 1;\n  andika 'zina ' + idadiYaTikiti + ' zilizobaki';\n  andika;\n};\n\n$idadiYaTikiti = 20;\n\nwakati [ idadiYaTikiti > 5 ] {\n  kulaTikiti::;\n};\n");var files={},currentFileName=null;function createFile(e){e.endsWith(".kiss")?files[e]?alert("File already exists"):(files[e]="",currentFileName=e,updateFileList(),closeModal()):alert("File must end with .kiss")}function updateFileList(){const e=document.getElementById("fileList");e.innerHTML="",Object.keys(files).forEach((t=>{const i=document.createElement("div");i.className="file-list-item"+(t===currentFileName?" active":""),i.innerHTML=`<i class="fas fa-file-code"></i><br>${t}`,i.onclick=()=>loadFile(t),e.appendChild(i)}))}function loadFile(e){currentFileName=e,editor.setValue(files[e]),document.getElementById("editorContainer").classList.remove("hidden"),document.getElementById("outputContainer").classList.add("hidden"),updateFileList()}function saveFile(){currentFileName?(files[currentFileName]=editor.getValue(),alert("File saved!")):alert("No file selected to save.")}function toggleEditor(){var e=document.getElementById("editorContainer"),t=document.getElementById("outputContainer");e.classList.contains("hidden")?(e.classList.remove("hidden"),t.classList.add("hidden")):(e.classList.add("hidden"),e.classList.add("hidden"),t.classList.remove("hidden"),Compile())}class Environment{constructor(e){this.errorHandler=new ErrorHandler,this.values={},this.enclosing=null,e&&(this.enclosing=e)}define(e,t){this.values[e]=t}assign(e,t){if(Object.keys(this.values).includes(e))this.values[e]=t;else{if(this.enclosing)return this.enclosing.assign(e,t);this.errorHandler.throw(`UNDEFINED VARIABLE ${e}`)}}get(e){return Object.keys(this.values).includes(e)?this.values[e]:this.enclosing?this.enclosing.get(e):void this.errorHandler.throw(`UNDEFINED VARIABLE ${e}`)}}class ErrorHandler{constructor(){this.log=globalLog}throw(e,t,i){let n;n=t&&i?`\n\n${e} -- ln: ${t}, col: ${i}\n`:`\n\n${e}\n`;try{throw new Error(n)}catch(e){console.error(e),this.log.error(e,t)}}}class Assignment{constructor(e,t,i,n){this.identifier=e.value,this.expression=t,this.evaluator=i,this.environment=n,this.evaluator.load(t),this.value=this.evaluator.evaluate().value,this.operate()}operate(){this.environment.assign(this.identifier,this.value)}}class Binary{constructor(e,t,i,n){this.evaluator=n,this.evaluator.load(e),this.leftNode=this.evaluator.evaluate(),this.evaluator.load(i),this.rightNode=this.evaluator.evaluate(),this.operator=t.type,this.value=this.operate()}operate(){return"PLUS"==this.operator?this.leftNode.value+this.rightNode.value:"MINUS"==this.operator?this.leftNode.value-this.rightNode.value:"MULTIPLY"==this.operator?this.leftNode.value*this.rightNode.value:"DIVIDE"==this.operator?this.leftNode.value/this.rightNode.value:"MODULO"==this.operator?this.leftNode.value%this.rightNode.value:"EQUALTO"==this.operator?this.leftNode.value==this.rightNode.value:"NOTEQUALTO"==this.operator?this.leftNode.value!=this.rightNode.value:"GREATERTHAN"==this.operator?this.leftNode.value>this.rightNode.value:"LESSTHAN"==this.operator?this.leftNode.value<this.rightNode.value:"GREATERTHANEQUAL"==this.operator?this.leftNode.value>=this.rightNode.value:"LESSTHANEQUAL"==this.operator?this.leftNode.value<=this.rightNode.value:void 0}}class Unary{constructor(e,t,i){this.evaluator=i,this.evaluator.load(t),this.operator=e,this.expression=t,this.value=this.operate()}operate(){return"MINUS"==this.operator.type?-this.evaluator.evaluate().value:"PLUS"==this.operator.type?this.evaluator.evaluate().value:"NOT"==this.operator.type?!this.evaluator.evaluate().value:void 0}}class Call{constructor(e,t,i,n){this.errorHandler=new ErrorHandler,this.callee=e,this.evaluator=i,this.args=this.evaluateArgs(t),this.environment=n,this.value=this.operate()}evaluateArgs(e){let t=[];for(let i of e){this.evaluator.load(i);let e=this.evaluator.evaluate().value;t.push(e)}return t}operate(){const e=this.environment.get(this.callee.value);return e instanceof ZapFunction||this.errorHandler.throw("INVALID CALLEE TYPE",this.callee.line,this.callee.col),e.call(this.args)}}class Literal{constructor(e){"NUMBER"==e.type&&(this.value=parseFloat(e.value)),"STRING"==e.type&&(this.value=e.value)}}class Group{constructor(e,t){this.evaluator=t,this.evaluator.load(e),this.value=this.evaluator.evaluate().value}}class Variable{constructor(e,t){this.identifier=e.value,this.environment=t,this.value=this.fetchValue()}fetchValue(){return this.environment.get(this.identifier)}}class Evaluator{constructor(e){this.environment=e,this.errorHandler=new ErrorHandler,this.rawExpression=null,this.index=null,this.previousToken=null,this.currentToken=null,this.nextToken=null,this.openingParen=0,this.closingParen=0,this.bars=0}load(e){this.rawExpression=e,this.resetToEnd()}reset(){this.index=0,this.previousToken=null,this.currentToken=this.rawExpression[this.index],this.nextToken=this.rawExpression[this.index+1],this.openingParen=0,this.closingParen=0,this.checkParenthese(),this.checkBar()}resetToEnd(){this.index=this.rawExpression.length-1,this.previousToken=this.rawExpression[this.index-1],this.currentToken=this.rawExpression[this.index],this.nextToken=null,this.openingParen=0,this.closingParen=0,this.checkParenthese(),this.checkBar()}next(){this.index++,this.previousToken=this.rawExpression[this.index-1],this.currentToken=this.rawExpression[this.index],this.nextToken=this.rawExpression[this.index+1],this.checkParenthese(),this.checkBar()}prev(){this.index--,this.previousToken=this.rawExpression[this.index-1],this.currentToken=this.rawExpression[this.index],this.nextToken=this.rawExpression[this.index+1],this.checkParenthese(),this.checkBar()}checkParenthese(){this.currentToken&&("LPAREN"==this.currentToken.type&&this.openingParen++,"RPAREN"==this.currentToken.type&&this.closingParen++)}checkBar(){this.currentToken&&"BAR"==this.currentToken.type&&this.bars++}isInGroup(){return this.openingParen!=this.closingParen||this.bars%2!=0}isOperator(e){return["MULTIPLY","DIVIDE","PLUS","MINUS","MODULO","GREATERTHAN","GREATERTHANEQUAL","LESSTHAN","LESSTHANEQUAL","EQUALTO","NOTEQUALTO","NOT"].includes(e.type)}isEqualityOperator(e){return["EQUALTO","NOTEQUALTO"].includes(e.type)}isComparissonOperator(e){return["GREATERTHAN","GREATERTHANEQUAL","LESSTHAN","LESSTHANEQUAL"].includes(e.type)}isAdditionOperator(e){return["PLUS","MINUS"].includes(e.type)}isMultiplicationOperator(e){return["MULTIPLY","DIVIDE","MODULO"].includes(e.type)}isUnaryOperator(e){return["MINUS","NOT","PLUS"].includes(e.type)}isLiteral(e){return["STRING","NUMBER"].includes(e.type)}isReserved(e){return["FOR","WHILE","RETURN","SHOW"].includes(e.type)}isForbidden(e){return["RBRACE","LBRACE","SEMICOLON","DOT","DECLARATOR"].includes(e.type)}handleAssignment(){let e=this.rawExpression.slice(0,this.index),t=this.rawExpression.slice(this.index+1);1==e.length&&t.length||this.errorHandler.throw("UNABLE TO PARSE ASSIGNMENT",this.currentToken.line,this.currentToken.col);let i=e[0];return"IDENTIFIER"!=i.type&&this.errorHandler.throw("INVALID ASSIGNEE",this.currentToken.line,this.currentToken.col),new Assignment(i,t,this,this.environment)}handleBinary(){let e=this.rawExpression.slice(0,this.index),t=this.rawExpression.slice(this.index+1);return e.length&&t.length||this.errorHandler.throw("UNABLE TO PARSE BINARY EXPRESSION",this.currentToken.line,this.currentToken.col),new Binary(e,this.currentToken,t,this)}handleUnary(){let e=this.rawExpression.slice(this.index+1);return e.length||this.errorHandler.throw("UNABLE TO PARSE UNARY EXPRESSION",this.currentToken.line,this.currentToken.col),new Unary(this.currentToken,e,this)}handleCall(){let e=this.previousToken,t=[],i=[];for(this.next(),this.currentToken||this.errorHandler.throw("UNABLE TO PARSE CALL EXPRESSION",this.previousToken.line,this.previousToken.col);"BAR"!=this.currentToken.type;)"COMMA"!=this.currentToken.type?i.push(this.currentToken):(t.push(i),i=[]),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED '|' after argument list",this.previousToken.line,this.previousToken.col);return i.length&&(t.push(i),i=[]),new Call(e,t,this,this.environment)}handleOpenParen(){let e=[];for(;this.isInGroup();)e.push(this.currentToken),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED ')' AFTER EXPRESSION -- EOF");return new Group(e,this)}handlePrimary(){return new Literal(this.currentToken)}handleVariable(){return new Variable(this.currentToken,this.environment)}handleReserved(){this.errorHandler.throw("UNEXPECTED KEYWORD",this.currentToken.line,this.currentToken.col)}handleForbidden(){this.errorHandler.throw("FORBIDDEN SYMBOL IN EXPRESSION",this.currentToken.line,this.currentToken.col)}evaluate(){for(;this.currentToken;)this.isForbidden(this.currentToken)&&this.handleForbidden(),this.prev();for(this.resetToEnd();this.currentToken;)this.isReserved(this.currentToken)&&this.handleReserved(),this.prev();for(this.reset();this.currentToken&&this.nextToken;)this.isLiteral(this.currentToken)&&this.isLiteral(this.nextToken)&&this.errorHandler.throw("UNEXPECTED LITERAL",this.nextToken.line,this.nextToken.col),this.next();for(this.reset();this.currentToken;){if("EQUALS"==this.currentToken.type&&!this.isInGroup())return this.handleAssignment();this.next()}for(this.resetToEnd();this.index>=0;){if(this.isEqualityOperator(this.currentToken)&&!this.isInGroup())return this.handleBinary();this.prev()}for(this.resetToEnd();this.index>=0;){if(this.isComparissonOperator(this.currentToken)&&!this.isInGroup())return this.handleBinary();this.prev()}for(this.resetToEnd();this.index>=0;){if(this.isAdditionOperator(this.currentToken)&&!this.isInGroup()&&this.previousToken&&!this.isOperator(this.previousToken))return this.handleBinary();this.prev()}for(this.resetToEnd();this.index>=0;){if(this.isMultiplicationOperator(this.currentToken)&&!this.isInGroup())return this.handleBinary();this.prev()}for(this.reset();this.currentToken;){if(this.isUnaryOperator(this.currentToken)&&!this.isInGroup())return this.handleUnary();this.next()}for(this.reset();this.currentToken;){if("BAR"==this.currentToken.type)return this.handleCall();this.next()}for(this.reset();this.currentToken;){if("LPAREN"==this.currentToken.type)return this.next(),this.handleOpenParen();this.next()}for(this.reset();this.currentToken;){if("NUMBER"==this.currentToken.type||"STRING"==this.currentToken.type)return this.handlePrimary();this.next()}for(this.reset();this.currentToken;){if("IDENTIFIER"==this.currentToken.type)return this.handleVariable();this.next()}return this.reset(),{value:void 0}}}class Interpreter{constructor(e){globalLog.clear(),this.errorHandler=new ErrorHandler,this.environment=new Environment(null),this.lexer=new Lexer(e),this.parser=new Parser(this.environment),this.parser.load(this.lexer.tokens),this.statements=this.parser.parse()}}class CharSeperator{constructor(e){this.errorHandler=new ErrorHandler,this.input=e,this.charTypes=[],this.getCharTypes()}getCharTypes(){let e=1,t=1;for(let i of this.input.split("")){for(let[n,r]of Object.entries(tokenList))if(r(i)){const r={};r.type=n,r.line=e,r.col=t,r.value=i,"UNRECOGNIZED"==r.type?this.errorHandler.throw("UNRECOGNIZED SYNTAX",r.line,r.col):this.charTypes.push(r);break}"\n"==i?(t=1,e++):t++}}}class Lexer{constructor(e){this.charSeperator=new CharSeperator(e),this.errorHandler=new ErrorHandler,this.charTypes=this.charSeperator.charTypes,this.index=0,this.char=this.charTypes[this.index],this.currentToken={},this.tokens=[],this.lex()}resetCurrentToken(){this.currentToken={}}next(){this.index++,this.char=this.charTypes[this.index]}peakNext(){try{return this.charTypes[this.index+1]}catch{return!1}}handleStr(){for(this.currentToken={type:"STRING",line:this.char.line,col:this.char.col,value:""},this.peakNext()?this.next():this.errorHandler.throw("EOF WHILE PARSING STRING",this.currentToken.line,this.currentToken.col);"QUOTE"!=this.char.type;)this.currentToken.value=this.currentToken.value.concat(this.char.value),this.next(),this.char||this.errorHandler.throw("EOF WHILE PARSING STRING",this.currentToken.line,this.currentToken.col);this.tokens.push(this.currentToken),this.resetCurrentToken(),this.next(),this.lex()}handleNum(){let e=!1;for(this.currentToken={type:"NUMBER",line:this.char.line,col:this.char.col,value:""};("NUMBER"==this.char.type||!e&&"DOT"==this.char.type&&this.peakNext()&&"NUMBER"==this.peakNext().type)&&("DOT"==this.char.type&&(e=!0),this.currentToken.value=this.currentToken.value.concat(this.char.value),this.next(),this.char););this.tokens.push(this.currentToken),this.resetCurrentToken(),this.lex()}handleId(){for(this.currentToken={type:"IDENTIFIER",line:this.char.line,col:this.char.col,value:""};("NUMBER"==this.char.type||"LETTER"==this.char.type)&&(this.currentToken.value=this.currentToken.value.concat(this.char.value),this.next(),this.char););Object.keys(reserved).includes(this.currentToken.value)&&(this.currentToken.type=reserved[this.currentToken.value]),this.tokens.push(this.currentToken),this.resetCurrentToken(),this.lex()}isDoubleCharOperator(){if(this.peakNext()){let e=this.char.value.concat(this.peakNext().value);for(let[t,i]of Object.entries(tokenList))if(i(e)&&"UNRECOGNIZED"!=t)return{type:t,line:this.char.line,col:this.char.col,value:e};return!1}}handleOperator(){if("WHITESPACE"!=this.char.type){let e=this.isDoubleCharOperator();e?(this.next(),this.currentToken=e,this.tokens.push(this.currentToken),this.resetCurrentToken()):(this.currentToken=this.char,this.tokens.push(this.currentToken),this.resetCurrentToken())}this.next(),this.lex()}lex(){if(this.char)switch(this.char.type){case"QUOTE":this.handleStr();break;case"NUMBER":this.handleNum();break;case"LETTER":this.handleId();break;default:this.handleOperator()}}}const tokenList={PLUS:e=>"+"==e,MINUS:e=>"-"==e,DIVIDE:e=>"/"==e,MULTIPLY:e=>"*"==e,MODULO:e=>"%"==e,EQUALS:e=>"="==e,GREATERTHAN:e=>">"==e,LESSTHAN:e=>"<"==e,NOT:e=>"!"==e,GREATERTHANEQUAL:e=>">="==e,LESSTHANEQUAL:e=>"<="==e,NOTEQUALTO:e=>"!="==e,EQUALTO:e=>"=="==e,FATARROW:e=>"=>"==e,LPAREN:e=>"["==e,RPAREN:e=>"]"==e,LBRACE:e=>"{"==e,RBRACE:e=>"}"==e,BAR:e=>":"==e,COMMA:e=>","==e,SEMICOLON:e=>";"==e,QUOTE:e=>"'"==e,DOT:e=>"."==e,DECLARATOR:e=>"$"==e,NUMBER:e=>/^[0-9]+$/.test(e),LETTER:e=>/^[a-zA-Z😘😂💕❤💓]+$/.test(e),WHITESPACE:e=>!/\S/.test(e),UNRECOGNIZED:e=>!0},reserved={ikiwa:"FOR",wakati:"WHILE",rudisha:"RETURN",andika:"SHOW",kama:"IF",au:"ELSE",kazi:"FUNCTION"};class Log{constructor(){this.values=[]}add(e){this.values.push({log:e})}error(e,t){this.values.push({error:{message:e.message,line:t}})}clear(){return this.values=[],this}}let globalLog=new Log;class BlockStmt{constructor(e,t){this.statement=e,this.body=this.fetchBody(),this.parser=new Parser(t),this.execute()}fetchBody(){return this.statement.slice(1,-1)}execute(){this.parser.load(this.body),this.statements=this.parser.parse()}}class PrintStmt{constructor(e,t,i){this.log=i,this.statement=e,this.expression=this.fetchExpression(),this.evaluator=t,this.value=null,this.execute()}fetchExpression(){return this.statement.slice(1)}execute(){this.evaluator.load(this.expression),this.value=this.evaluator.evaluate().value,null!=this.value?this.log.add(this.value):this.log.add("")}}class ExprStmt{constructor(e,t){this.expression=e,this.evaluator=t,this.evaluator.load(this.expression),this.value=this.evaluator.evaluate().value}}class DeclarationStmt{constructor(e,t,i){this.errorHandler=new ErrorHandler,this.statement=e,this.evaluator=t,this.environment=i,this.value=null,this.identifier=e[1].value,this.execute()}fetchValue(){let e=null;if(this.statement[2])if("EQUALS"==this.statement[2].type){let t=this.statement.slice(3);this.evaluator.load(t),e=this.evaluator.evaluate().value,null==e&&this.errorHandler.throw("INVALID DECLARATION STATEMENT",this.statement[0].line,this.statement[0].col)}else this.errorHandler.throw("INVALID DECLARATION STATEMENT",this.statement[0].line,this.statement[0].col);return e}execute(){return this.value=this.fetchValue(),this.environment.define(this.identifier,this.value)}}class IfStmt{constructor(e,t,i){this.evaluator=t,this.parser=new Parser(i),this.errorHandler=new ErrorHandler,this.statement=e,this.expression=[],this.thenBlock=[],this.elseBlock=null,this.index=1,this.currentToken=this.statement[this.index],this.prevToken=null,this.openingBrace=0,this.closingBrace=0,this.execute()}next(){this.prevToken=this.statement[this.index],this.index++,this.currentToken=this.statement[this.index],this.checkBrace()}checkBrace(){this.currentToken&&("LBRACE"==this.currentToken.type&&this.openingBrace++,"RBRACE"==this.currentToken.type&&this.closingBrace++)}isInBlock(){return this.closingBrace!=this.openingBrace}splitBlock(){for(;!this.isInBlock();)this.expression.push(this.currentToken),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED '{' AFTER EXPRESSION",this.prevToken.line,this.prevToken.col);for(;this.isInBlock();)this.thenBlock.push(this.currentToken),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED '}' AFTER THEN BLOCK",this.prevToken.line,this.prevToken.col);if(this.thenBlock.push(this.currentToken),this.thenBlock.push({type:"SEMICOLON",value:";"}),this.next(),this.currentToken)if("ELSE"==this.currentToken.type)if(this.next(),this.isInBlock()){for(this.elseBlock=[];this.isInBlock();)this.elseBlock.push(this.currentToken),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED '}' AFTER ELSE BLOCK",this.prevToken.line,this.prevToken.col);this.elseBlock.push(this.currentToken),this.elseBlock.push({type:"SEMICOLON",value:";"}),this.next()}else this.errorHandler.throw("UNABLE TO PARSE ELSE STATEMENT",this.prevToken.line,this.prevToken.col);else this.errorHandler.throw("UNEXPECTED KEYWORD AFTER IF STATEMENT",this.prevToken.line,this.prevToken.col)}execute(){this.splitBlock(),this.evaluator.load(this.expression);let e=this.evaluator.evaluate().value;e&&(this.parser.load(this.thenBlock),this.parser.parse()),e||this.elseBlock&&(this.parser.load(this.elseBlock),this.parser.parse())}}class WhileStmt{constructor(e,t,i){this.evaluator=t,this.parser=new Parser(i),this.errorHandler=new ErrorHandler,this.statement=e,this.expression=[],this.body=[],this.index=1,this.currentToken=this.statement[this.index],this.prevToken=null,this.openingBrace=0,this.closingBrace=0,this.execute()}next(){this.prevToken=this.statement[this.index],this.index++,this.currentToken=this.statement[this.index],this.checkBrace()}checkBrace(){this.currentToken&&("LBRACE"==this.currentToken.type&&this.openingBrace++,"RBRACE"==this.currentToken.type&&this.closingBrace++)}isInBlock(){return this.closingBrace!=this.openingBrace}splitBlock(){for(;!this.isInBlock();)this.expression.push(this.currentToken),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED '{' AFTER EXPRESSION",this.prevToken.line,this.prevToken.col);for(;this.isInBlock();)this.body.push(this.currentToken),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED '}' AFTER BODY OF WHILE",this.prevToken.line,this.prevToken.col);this.body.push(this.currentToken),this.body.push({type:"SEMICOLON",value:";"}),this.next(),this.currentToken&&this.errorHandler.throw("UNEXPECTED TOKEN AFTER WHILE STATEMENT",this.currentToken.line,this.currentToken.col)}execute(){this.splitBlock();let e=1e3;for(this.evaluator.load(this.expression);this.evaluator.evaluate().value;)if(this.parser.load(this.body),this.parser.parse(),this.evaluator.load(this.expression),e--,e<=0){this.errorHandler.throw("MAXIMUM NUMBER OF LOOPS EXCEEDED");break}}}class FunctionStmt{constructor(e,t,i){this.evaluator=t,this.environment=i,this.errorHandler=new ErrorHandler,this.statement=e,this.identifier=null,this.args=[],this.body=[],this.index=1,this.currentToken=this.statement[this.index],this.prevToken=null,this.execute()}next(){this.prevToken=this.statement[this.index],this.index++,this.currentToken=this.statement[this.index]}splitBlock(){for(this.identifier=this.currentToken.value,this.next(),this.currentToken&&"BAR"==this.currentToken.type||this.errorHandler.throw("EXPECTED '|' AFTER FUNCTION DECLARATION",this.prevToken.line,this.prevToken.col),this.next();this.currentToken&&"BAR"!=this.currentToken.type&&(this.args.push(this.currentToken),this.next(),this.currentToken||this.errorHandler.throw("EXPECTED '|' AFTER ARGUMENT LIST",this.prevToken.line,this.prevToken.col),"COMMA"!=this.currentToken.type&&"BAR"!=this.currentToken.type&&this.errorHandler.throw("EXPECTED ',' AFTER ARGUMENT",this.prevToken.line,this.prevToken.col),"BAR"!=this.currentToken.type);)this.next();this.next(),this.currentToken&&"FATARROW"==this.currentToken.type||this.errorHandler.throw("EXPECTED '=>' AFTER FN DECLARATION",this.prevToken.line,this.prevToken.col),this.next(),this.body=this.statement.slice(this.index),this.body.push({type:"SEMICOLON",value:";"})}execute(){this.splitBlock();const e=new ZapFunction(this.identifier,this.args,this.body,this.environment);this.environment.define(this.identifier,e)}}class Parser{constructor(e){this.environment=e,this.evaluator=new Evaluator(this.environment),this.errorHandler=new ErrorHandler,this.log=globalLog,this.tokens=null,this.index=null,this.currentToken=null,this.previousToken=null,this.statements=[],this.currentStatement=[],this.openingBrace=0,this.closingBrace=0}load(e){this.tokens=e,this.index=0,this.currentToken=this.currentToken=this.tokens[this.index],this.previousToken=null,this.openingBrace=0,this.closingBrace=0,this.checkBrace()}resetCurrentStatement(){this.currentStatement=[]}checkBrace(){this.currentToken&&("LBRACE"==this.currentToken.type&&this.openingBrace++,"RBRACE"==this.currentToken.type&&this.closingBrace++)}next(){this.index++,this.currentToken=this.tokens[this.index],this.previousToken=this.tokens[this.index-1],this.checkBrace()}isInBlock(){return this.openingBrace!=this.closingBrace}isSemicolon(){return"SEMICOLON"==this.currentToken.type}handleBlock(e){return new BlockStmt(e,new Environment(this.environment))}handlePrint(e){return new PrintStmt(e,this.evaluator,this.log)}handleDeclaration(e){return new DeclarationStmt(e,this.evaluator,this.environment)}handleIf(e){return new IfStmt(e,this.evaluator,this.environment)}handleExpression(e){return new ExprStmt(e,this.evaluator)}handleWhile(e){return new WhileStmt(e,this.evaluator,this.environment)}handleFunction(e){return new FunctionStmt(e,this.evaluator,this.environment)}handleStatement(e){return"LBRACE"==e[0].type?this.handleBlock(e):"SHOW"==e[0].type?this.handlePrint(e):"DECLARATOR"==e[0].type?this.handleDeclaration(e):"IF"==e[0].type?this.handleIf(e):"WHILE"==e[0].type?this.handleWhile(e):"FUNCTION"==e[0].type?this.handleFunction(e):this.handleExpression(e)}parse(){for(;this.currentToken;)if(this.isInBlock()){if(this.currentStatement.push(this.currentToken),!this.isInBlock()){let e=this.handleStatement(this.currentStatement);this.statements.push(e),this.resetCurrentStatement()}this.next()}else{if(this.isSemicolon()){let e=this.handleStatement(this.currentStatement);this.statements.push(e),this.resetCurrentStatement()}else this.currentStatement.push(this.currentToken);this.next()}return this.currentStatement.length&&this.errorHandler.throw("YOU MUST HAVE FORGOTTEN A SEMICOLON OR CLOSING BRACE",this.previousToken.line,this.previousToken.col),this.statements}}class ZapFunction{constructor(e,t,i,n){this.errorHandler=new ErrorHandler,this.environment=new Environment(n),this.parser=new Parser(this.environment),this.name=e,this.args=t,this.body=i,this.arity=t.length}call(e){e.length!=this.args.length&&this.errorHandler.throw(`INVALID NUMBER OF ARGUMENTS PASSED TO ${this.name}`);for(let t=0;t<e.length;t++)this.environment.define(this.args[t].value,e[t]);this.parser.load(this.body),this.parser.parse()}}class kiswahiliScript{constructor(e){this.input=e,this.interpreter=new Interpreter(this.input)}}function Compile(){var e=editor.getValue();const t=performance.now(),i=(new kiswahiliScript(e),globalLog.values.map((e=>e.log?e.log:e.error?`Error: ${e.error.message} at line ${e.error.line}`:"")).join("<br>"));document.getElementById("s").innerHTML=i;const n=performance.now(),r=n-t;document.getElementById("s").innerHTML=`\n            kiswahiliScript with .kiss\n            ========  ====== ====== =====\n            \n            <div>Time taken: ${r.toFixed(2)} ms</div>\n            ~~~ compilation results ~~~~~~\n            \n            <div>${i}</div>\n            ====>time start:${t}\n            ====>time end:${n}\n            \n            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n            developed by Silivestir Assey ,Isack Wagunda\n            Under splannes team ©splannes 2024\n            maintained by Silivestir Assey \n            -------     ----------   ----------\n            see docs at kiswahiliScript page\n            report bugs,disclaimer,privacy,\n            \n            `}function openModal(){document.getElementById("fileModal").style.display="block"}function closeModal(){document.getElementById("fileModal").style.display="none"}function toggleTerminal(){var e=document.getElementById("editorContainer"),t=document.getElementById("terminalContainer");t.classList.contains("hidden")?(e.classList.add("hidden"),t.classList.remove("hidden"),document.getElementById("terminalInput").focus()):(t.classList.add("hidden"),e.classList.remove("hidden"))}document.getElementById("fileForm").addEventListener("submit",(function(e){e.preventDefault(),createFile(document.getElementById("fileName").value)}));var isDone=!1;function executeCommand(e){const t=document.getElementById("terminalOutput"),i=e.trim().split(/\s+/),n=i[0],r=i[1];if("kiswahili"===n)switch(i[1]){case"clear":t.innerHTML="";break;case"mkfile":createFile(i[2]),t.innerHTML+="> File created\n";break;case"run":isDone||(t.innerHTML+="><span>huez ku run program bila ku compail "),isDone&&compile();break;case"compail":t.innerHTML+="> Compilation successful\n",isDone=!0,setTimeout((function(){t.innerHTML+="> <br>.."}),1e3),setTimeout((function(){t.innerHTML+=" ......."}),1e3),setTimeout((function(){t.innerHTML+="> now run your program\n"}),1e3);break;case"delete":delete files[r],t.innerHTML+="> File deleted\n",updateFileList();break;default:i[1].endsWith(".kiss")?handleFileCommands(i[1],i[0]):t.innerHTML+="> Unknown command\n"}else t.innerHTML+="> Unknown command\n";t.scrollTop=t.scrollHeight}function handleFileCommands(e,t){const i=document.getElementById("terminalOutput");"compile"===t?files[e]?(alert(files[e]),i.innerHTML+="> Compilation successful\n"):i.innerHTML+="> Compilation error: File not found\n":"run"===t?files[e]?(i.innerHTML+="> Running program...\n",i.innerHTML+=`> ${files[e]}\n`):i.innerHTML+="> Error: File not found\n":"delete"===t?files[e]?(delete files[e],i.innerHTML+="> File deleted\n",updateFileList()):i.innerHTML+="> Error: File not found\n":i.innerHTML+="> Unknown file command  ${args[1]}\n"}function compile(){var e=editor.getValue();const t=performance.now(),i=(new kiswahiliScript(e),globalLog.values.map((e=>e.log?e.log:e.error?`Error: ${e.error.message} at line ${e.error.line}`:"")).join("<br>")),n=document.getElementById("terminalOutput");n.innerHTML=i;const r=performance.now(),s=r-t;n.innerHTML=`\n            kiswahiliScript with .kiss\n            ========  ====== ====== =====\n            \n            <div>Time taken: ${s.toFixed(2)} ms</div>\n            ~~~ compilation results ~~~~~~\n            \n            <div>${i}</div>\n            ====>time start:${t}\n            ====>time end:${r}\n            \n            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n            developed by Silivestir Assey ,Isack Wagunda\n            Under splannes team ©splannes 2024\n            maintained by Silivestir Assey \n            -------     ----------   ----------\n            see docs at kiswahiliScript page\n            report bugs,disclaimer,privacy,\n            \n            `}document.getElementById("terminalInput").addEventListener("keypress",(function(e){if("Enter"===e.key){e.preventDefault();executeCommand(this.value),this.value=""}}))</script>
</body>
</html>
